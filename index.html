<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport"content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
  
  
  <title>  JellyP </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/style.min.css"> 
</head>  
  <body>   
    <header class="header">
	
  <nav class="header-nav">       
	
  	<span class="iconfont icon-menu mobile-toggle"></span>  

    <a class="header-logo" href="/"><span>JellyP</a>  

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">Home</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">Archives</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-categories" href="/categories">Categories</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">Tags</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">About</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>   

    <div class="container">       
      
        

          <section id="main">  

        

        


<div class="profile sildeUpMin">

	<img class="avatar" src="/images/header.jpg"  alt="No Avatar.">
					
		<p class="author">PengGuodong</p>

		
			<p class="location"><span class="iconfont icon-location"></span>GuangZhou CN</p>
		
	
		<div class="social">
   		   
   		<span data-hover="Github">
		<a class="iconfont icon-Github" target="_blank" href="https://github.com/JellyP" >		
		</a></span>
	    
    </div>		
</div>

      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/">effective Objective-C 2.0 总结与笔记（第二章）—— 对象、消息、运行期</a>  
	       
		 

		 <time>2018-11-10 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第二章：对象、消息、运行期"><a href="#第二章：对象、消息、运行期" class="headerlink" title="第二章：对象、消息、运行期"></a>第二章：对象、消息、运行期</h3><p>​    “对象”就是“基本构造单元”，开发者可以通过对象来存储并传递数据。对象之间传递数据并执行任务的过程就是“消息传递”。程序运行起来后，为其提供相关支持的代码就是“Objective-C运行期环境”，它提供了一些使得对象之间能够传递消息的重要函数，并且包括创建类实例所用的全部逻辑。</p>
<h4 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h4><ul>
<li>”属性“ (property) 是Objective-C的一项特性，用于封装对象中的数据。实例变量一般通过“存取方法”来访问，其中getter用于读取变量值，setter用于写入变量值。开发者可以令编译器自动编写与属性有关的存取方法。</li>
<li>Objective-C语言很少将实例变量放在类接口的public区段内，更多的是使用<code>@property</code>的方式来声明。这是因为如果直接使用public的区段，当实例变量的偏移量改变（原有的实例变量里插入了新的实例变量）的时候，需要重新编译，假如代码库中某份代码使用了旧的类定义，就会出现不兼容的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//public区段内声明实例变量</span><br><span class="line">@interface EOCPerson : NSObject &#123;</span><br><span class="line">@public</span><br><span class="line">    NSData *_dataOfBirth;</span><br><span class="line">    NSString *_firstName;</span><br><span class="line">    NSString *_lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用@property方式声明</span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//@property方式等效于</span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (NSString *)firstName;</span><br><span class="line">- (void)setFirstName;</span><br><span class="line">- (NSString *)lastName;</span><br><span class="line">- (void)setLastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果要访问属性，可以使用“点语法”，编译器会把“点语法”转换成对存取方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EOCPerson *aPerson = [EOCPerson new];</span><br><span class="line">aPerson.firstName = @&quot;GDGD&quot;;//same as</span><br><span class="line">[aPerson setFirstName:@&quot;GDGD&quot;];</span><br><span class="line"></span><br><span class="line">NSString *lastNameOfGD = aPerson.lastName;//same as</span><br><span class="line">NSString *lastNameOfGD = [aPerson lastName];</span><br></pre></td></tr></table></figure>
<p>使用属性的方式进行声明实例变量，编译器会自动生成存取方法，虽然这个时候在编译器上<strong>看不到</strong>生成的方法，这个方法默认的名字是：getter—就是属性的名字，setter—属性名字前面加set。</p>
<p>如果想要修改“合成方法”的名字，可以使用@synthesize语法来指定关键字的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在实现文件中</span><br><span class="line">@implementation EOCPerson</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果不想要编译器自动生成的方法，可以使用@dynamic语法来阻止编译器的生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation EOCPerson</span><br><span class="line">@dynamic firstName, lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>属性具有四种特质，不同的特质也会影响属性生成的存取方法。</li>
</ul>
<p>(1)、原子性：默认情况下，编译器所合成的方法会通过锁定机制确保其原子性 (atomicity) 。如果属性具备nonatomic特质，则不使用同步锁。<strong>在iOS开发的程序里，由于同步锁开销较大，如果使用原子性的属性会导致性能问题，所以属性都是nonatomic的特质。</strong></p>
<p>(2)、读写权限：</p>
<p>​    readwrite (读写) ：拥有前面说的获取方法 (getter) 和设置方法 (setter)，默认情况。</p>
<p>​    readonly (只读) ：仅拥有获取方法。可以对外暴露为只读属性，然后在“class-continuation分类”中重新定义为读写属性。（27条有说）</p>
<p>(3)、内存管理语义：这是最难理解的部分了，虽然这个特质仅会影响“设置方法”，但是其中涉及到内存管理部分，所以还是非常重要。</p>
<p>​    assign：“设置方法”只会针对“纯量类型”（scalar type，例如CGFloat，NSInteger等）的简单赋值。一般在之前分配在栈里的数据类型就是使用assign修饰。</p>
<p>​    strong：此特质表示一种拥有关系，当给这种属性设置新值的时候，会先保留新值，再释放旧值，然后设置新值上去，一般Objective-C对象使用这个修饰词。</p>
<p>​    weak：表示非拥有关系，为这种属性设置新值的时候，不保留新值，也不释放旧值，当属性所指的对象被销毁的时候，属性值也会被清空。这就是一种弱持有，一般可以用来打破循环引用的情况（后面会介绍）。</p>
<p>​    unsafe_unretained ：语义和assign相同，但是适用于对象类型（object type)，表示一种非拥有关系，但是当目标对象被销毁的时候，属性值不会被清空。</p>
<p>​    copy：和strong类似，但是设置方法并不保留新值，而是将其拷贝。一般NSString <em>就使用这个特质来修饰。这是因为NSString </em>有可能指向一个可变的NSMutableString 实例，如果使用的不是copy的话，那么当可变字符串被篡改后，会影响到你不可变的字符串，所以要拷贝一个不可变的字符串。</p>
<p>(4)、方法名：可以用来指定存取方法的方法名。</p>
<p>​    getter=\&lt;name>：指定获取方法的方法名，如果某属性是Boolean，一般会用这种方式来在获取方法名上加上<code>is</code>前缀。</p>
<p>​    setter=\&lt;name>：指定设置方法的方法名，较少使用。</p>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>在对象之外访问实例变量是通过属性来实现，但是当在对象内部访问实例变量的话最好采用直接访问的形式，而在设置实例变量的时候才通过属性来做。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//使用属性访问</span><br><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFullName &#123;</span><br><span class="line">    NSArray *components = [[self fullName] componentsSeparatedByString:@&quot; &quot;];</span><br><span class="line">    self.firstName = components[0];</span><br><span class="line">    self.lastName = components[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用实例变量访问</span><br><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFullName &#123;</span><br><span class="line">    NSArray *components = [[self fullName] componentsSeparatedByString:@&quot; &quot;];</span><br><span class="line">    _firstName = components[0];</span><br><span class="line">    _lastName = components[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用实例变量和属性访问的区别如下：</p>
<ul>
<li>使用实例变量直接访问由于不经过方法派发，直接访问保存实例变量的那块内存，所以速度更快。</li>
<li>直接访问实例变量可以绕过内存管理语义。</li>
<li>直接访问实例变量不会出发KVO (Key-Value Observing)。</li>
<li>通过属性可以帮助自己debug的时候排查与之相关的错误。</li>
</ul>
<p>知道以上的区别了之后，一般采用一种折中的方案，设置属性使用“设置方法“，读取实例变量则直接访问。</p>
</li>
<li><p>在初始化的时候，如果需要设置实例变量，应当直接访问，因为子类可能会”覆写“设置方法，导致调用到子类的设置方法的时候，出现意想不到的结果。</p>
</li>
<li><p>如果使用了懒加载的方式，就需要使用属性的方式来访问实例变量。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//lazy initialization</span><br><span class="line">- (NSString *)firstName &#123;</span><br><span class="line">    if (!_firstName) &#123;</span><br><span class="line">        _firstName = @&quot;GDGD&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return _firstName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h4><ul>
<li>由于<code>==</code>操作符比较出来的结果未必是我们想要的，因为该操作符是两个指针本身，而不是指针所指的对象。所以一般使用NSObject协议中声明的”isEqual“方法来判断两个对象的等同性。如果是自定义的类，则需要重写该方法以实现等同性判断。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *foo = @&quot;hhh123&quot;;</span><br><span class="line">NSString *bar = [NSString stringWithFormat:@&quot;hhh%i&quot;,123];</span><br><span class="line">Boolean equalA = (foo == bar); // NO</span><br><span class="line">Boolean equalB = [foo isEqual:bar];//YES</span><br><span class="line">Boolean equalC = [foo isEqualToString:bar];//YES</span><br></pre></td></tr></table></figure>
<ul>
<li>NSObject协议中判断对象等同性主要是两个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object;</span><br><span class="line">- (NSUInteger)hash;</span><br></pre></td></tr></table></figure>
<p>NSObject对这两个方法的默认实现是：指针值完全相等的时候，两个对象才相等。如果isEqual方法为Yes，那么两个对象的hash值相等，反之<strong>不成立</strong>。理解这个意义是自定义实现<code>isEqual:</code>的关键。</p>
<p>设计hash方法的时候，需要尽量减少对象的碰撞，防止出现运算复杂度过大的情况。</p>
<ul>
<li>特定类所具有的等同性判定方法：由于Objective-C在编译期没有做强类型转换，为了增强代码的鲁棒性，应该保证所传对象的类型正确，且有异常处理逻辑。</li>
<li>等同性判定的执行深度：如果是对数组进行等同性判定，往往需要比较两个数组的对应位置的所有对象，这样叫做“深度等同性判定”，如果可以通过identifier来标示等同性，就能大大节省计算。</li>
<li>容器中可变类的等同性：在容器加入可变类对象的时候，把某个对象放入容器之后，就不应该改变其hash值了。由于容器会根据其hash值放在不同的“箱子数组”里，如果放入箱子之后hash值又改变了，那么证明容器放错了箱子，可能会出现隐患。所以需要保证hash值不是根据对象的可变部分来实现的，或者是在其放入容器后就不再改变hash值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSMutableSet *set = [NSMutableSet new];</span><br><span class="line"></span><br><span class="line">NSMutableArray *arrayA = [@[@1, @2] mutableCopy];</span><br><span class="line">[set addObject:arrayA];</span><br><span class="line">//set = &#123;((1,2))&#125;</span><br><span class="line"></span><br><span class="line">NSMutableArray *arrayB = [@[@1] mutableCopy];</span><br><span class="line">[set addObject:arrayB];</span><br><span class="line">//set = &#123;((1),(1,2))&#125;</span><br><span class="line"></span><br><span class="line">[arrayB addObject:@2];</span><br><span class="line">//set = &#123;((1,2),(1,2))&#125; 打破了set的语义</span><br><span class="line"></span><br><span class="line">NSSet *copySet = [set copy];</span><br><span class="line">//copySet = &#123;((1,2))&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第9条：以”类族模式“隐藏实现细节"><a href="#第9条：以”类族模式“隐藏实现细节" class="headerlink" title="第9条：以”类族模式“隐藏实现细节"></a>第9条：以”类族模式“隐藏实现细节</h4><ul>
<li>类族模式可以把实现细节隐藏在一套简单的公共接口后面。Objective-C的系统框架中普遍使用该模式，用户无需自己创建子类实例，只需要调用基类方法来创建即可。</li>
<li>一般采用工厂模式来创建类族。由于Objective-C这门语言没办法指明某个基类是”抽象“的，所以如果使用了类族模式需要写上相应的注释。</li>
<li>Cocoa里的类族：大部分collection类都是类族，如果要子类化这些类族，需要遵守一些规则：<ul>
<li>子类应到继承自类族中的抽象基类：如果要编写NSArray类族的子类，需要继承自不可变数组的基类或者可变数组的基类。</li>
<li>子类应该定义自己的数据存储方式。</li>
<li>子类应当覆写超类文档中指明需要覆写的方法。</li>
</ul>
</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><ul>
<li><p>有时候类的实例可能是由某种机制所创建的，那么也就是无法创建出自己所写的子类实例，那么也就是如果你需要存放对象到类中，就不能通过创建子类的方式实现了。而Objective-C的“关联对象” (associated object) 可以解决这个问题。</p>
<ul>
<li><p>可以给某个对象关联多个对象，通过“键”来区分，同时在创建关联对象的时候，也有相应的“内存管理语义”，由名为<code>objc_AssociationPolicy</code>的枚举所定义。</p>
<p>|             关联类型              | 等效的@property属性 |<br>| :——————————-: | :—————–: |<br>|      OBJC_ASSOCIATION_ASSIGN      |       assign        |<br>|  OBJC_ASSOCIATION_COPY_NONATOMIC  |   nonatomic、copy   |<br>| OBJC_ASSOCIATION_RETAIN_NONATOMIC |  nonatomic、retain  |<br>|       OBJC_ASSOCIATION_COPY       |        copy         |<br>|      OBJC_ASSOCIATION_RETAIN      |       retain        |</p>
</li>
</ul>
</li>
<li><p>管理关联对象的方法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//此方法以给定的键和策略为某对象设置关联对象</span><br><span class="line">- void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line"></span><br><span class="line">//此方法根据给定的键从某对象中获取相应的关联对象值</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);</span><br><span class="line"></span><br><span class="line">//此方法移除指定对象的全部关联对象</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure>
<p>可以把对象想象成NSDictionary，把关联到该对象的值理解为字典的条目，本质的区别在于设置关联对象的key是个不透明的指针，在NSDictionary里如果两个键值相等那么<code>isEqual:</code>方法的返回值就是YES，但是关联对象必须是两个指针相同才行，在设置关联对象的时候通常使用<strong>静态全局变量</strong>做键。</p>
<h4 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h4><ul>
<li>Objective-C的方法调用方式是消息结构，这种传递消息需要有“名称”或“选择子”，可以接受参数，而且可能还有返回值。在Objective-C中，如果向某对象传递消息，那么就会使用动态绑定机制来决定需要调用的方法，当对象收到消息之后，究竟该调用那个方法完全由运行期决定，同时可以在程序运行时改变。</li>
<li>给对象发送消息的例子和过程如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">someObject —— 接受者</span><br><span class="line">messageName —— 选择子</span><br><span class="line">parameter —— 参数</span><br><span class="line">**/</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br><span class="line"></span><br><span class="line">//编译器看到这个消息之后会转换成一条标准的C语言函数调用，调用的是消息中心的核心函数，objc_msgSend</span><br><span class="line">void objc_msgSend(id self, SEL cmd, ...);</span><br><span class="line"></span><br><span class="line">//所以上面那个函数调用经过编译器会转换成如下函数--&gt;</span><br><span class="line">id returnValue = objc_msgSend(someObject,</span><br><span class="line">                              @selector(messageName:),</span><br><span class="line">                              parameter);</span><br><span class="line"></span><br><span class="line">//obj_msgSend函数会依据接受者和选择子的类型来调用适当的方法，为了完成此操作的方法需要在接受者所属类中搜寻方法列表，如果有就跳到其执行的代码，如果没找到就沿着体系继续往上查找，找到合适的方法再跳转。如果还没有，后面就会涉及到消息转发机制。</span><br><span class="line">//obj_msgSend会将匹配结果换存在”快速映射表“里，这样每个类其实都有这样一块缓存，所以执行起来很快，但是还是不如”静态绑定的函数调用操作“那样迅速。</span><br></pre></td></tr></table></figure>
<ul>
<li>除了上述的部分消息的调用过程，还有一些”边界情况“，则需要交由Objective-C运行环境中的一些函数来处理：<ul>
<li>objc_msgSend_stret：如果待发送的消息要返回结构体，那么可以交由此函数处理。需要CPU的寄存器能够容纳这个消息返回的结构体，如果无法容纳就会由另一个函数进行派发，那个函数会通过分配在栈上的某个变量来处理返回的结构体。</li>
<li>objc_msgSend_fpret：如果消息返回的是浮点数，那么需要交由此函数处理。这个函数是为了处理x86等架构CPU中某些奇怪状况。</li>
<li>objc_msgSendSuper：如果要给超类发消息，就给这个函数处理。</li>
</ul>
</li>
<li>如果某函数的最后一项操作是调用另外一个函数，就可以使用“尾调用优化”技术。编译器会生成跳转到另一函数所需要的指令码，而不用向调用堆栈里推入新的”栈帧“。当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用的时候，才能执行”尾调用优化“。</li>
</ul>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><ul>
<li><p>在编译期向类发送了其无法解读的消息并不会报错，因为运行期可以向类中添加方法，所以编译器在编译时无法确定类中到底会不会有某个方法实现。当对象接收到无法解读的消息后，就会启动”消息转发“机制。</p>
</li>
<li><p>消息转发分为两大阶段：</p>
<ul>
<li>第一阶段先征询接受者所属的类，看其是否能动态添加方法，以处理当前这个”未知的选择子“，这部分叫”动态方法解析“。注意这是一个类方法，因为是向接收者所属的类进行请求。</li>
<li>第二阶段涉及”完整的消息转发机制“，这里细分为两小步：<ul>
<li>当对象所属类不能动态添加方法后，<code>runtime</code>就会询问当前的接受者是否有其他对象可以处理这个未知的<code>selector</code>。</li>
<li>当没有备援接收者时，就只剩下最后一次机会，那就是消息重定向。这个时候<code>runtime</code>会将未知消息的所有细节都封装为<code>NSInvocation</code>对象，给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
</li>
<li><p>动态方法解析：</p>
<ul>
<li>对象收到无法解读的消息后，首先调用其所属类的类方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
<p>这种方法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面就可以了。此方案常用来实现<code>@dynamic</code>属性。</p>
<p>Example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//假设这两个方法已经实现</span><br><span class="line">id autoDictionaryGetter(id self,SEL _cmd);</span><br><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value);</span><br><span class="line"></span><br><span class="line">//使用这个类方法进行消息转发</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">    if (/* selector is from a @dynamic property */) &#123;</span><br><span class="line">        if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</span><br><span class="line">            class_addMethod(self,</span><br><span class="line">                            sel,</span><br><span class="line">                            (IMP)autoDictionarySetter,</span><br><span class="line">                            &quot;v@:@&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            class_addMethod(self,</span><br><span class="line">                            sel,</span><br><span class="line">                            (IMP)autoDictionaryGetter,</span><br><span class="line">                            &quot;@@:&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备援接收者：</p>
<ul>
<li>当前接受者还有第二次机会能处理未知的选择子，在这一步中，系统会问该选择子能不能转发给其他接受者。相关的方法为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>虽然Objective-C不支持多重继承，但是通过这个函数的组合我们可以模拟出多次继承的某些特性。</p>
</li>
<li><p>完整的消息转发：</p>
<ul>
<li>首先创建NSInvocation对象，把尚未处理的那条消息的所有细节都封在其中，包括选择子、目标和参数，这个步骤会调用下列方法来转发消息:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation;</span><br></pre></td></tr></table></figure>
<p>实现此方法的时候，如果发现某调用操作不应由本类处理，则需调用超类的同名方法，这样继承体系中的每个类都有机会处理此调用请求，直到NSObject。</p>
</li>
<li><p>消息转发流程：</p>
</li>
</ul>
<p><img src="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/2.jpg" alt="2"></p>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		8679
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/09/effective-Objective-C-2-0-总结与笔记（第一章）/">effective Objective-C 2.0 总结与笔记（第一章）—— 熟悉Objective-C</a>  
	       
		 

		 <time>2018-11-09 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第一章：熟悉Objective-C"><a href="#第一章：熟悉Objective-C" class="headerlink" title="第一章：熟悉Objective-C"></a>第一章：熟悉Objective-C</h3><p>​    本章主要是对Objective-C进行一个了解，通过介绍Objective-C的语法，来讲解Objective-C的基础知识。</p>
<h4 id="第1条：了解Objective-C语言的起源"><a href="#第1条：了解Objective-C语言的起源" class="headerlink" title="第1条：了解Objective-C语言的起源"></a>第1条：了解Objective-C语言的起源</h4><ul>
<li>Objective-C语言采用“消息结构”而非“函数调用”，虽然也是一门面向对象的语言，但是语法比较特别。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息结构:(Objective-C)</span></span><br><span class="line">Object *obj = [Object <span class="keyword">new</span>];</span><br><span class="line">[obj doSomethingWith:someParams];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用:(C++)</span></span><br><span class="line">Object *obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj-&gt;doSomething(someParams);</span><br></pre></td></tr></table></figure>
<p>采用消息结构的语言：执行代码由运行环境决定。</p>
<p>采用函数调用的语言：执行代码由编译器决定。</p>
<ul>
<li>Objective-C的对象所占内存分配在堆空间，不能在栈空间中分配Objective-C对象。通常Objective-C对象类型有一个<code>*</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">someString -&gt; 分配在堆里的某块 含有一个叫&quot;the string&quot;的NSString对象 的内存</span><br><span class="line">anotherString -&gt; someString 指向的那块内存</span><br><span class="line"></span><br><span class="line">只有1个NSString实例，2个变量（指针）在栈帧中被分配了两个内存，内存的值都是上面的堆内存地址</span><br><span class="line">*/</span><br><span class="line">NSString *someString = @&quot;the string&quot;;</span><br><span class="line">NSString *anotherString = someString;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中不含<code>*</code>的可能会使用栈内存，例如<code>CGFloat</code>、<code>CGRect</code> etc.</p>
<h4 id="第2条：在类的头文件中尽量少引入其他头文件"><a href="#第2条：在类的头文件中尽量少引入其他头文件" class="headerlink" title="第2条：在类的头文件中尽量少引入其他头文件"></a>第2条：在类的头文件中尽量少引入其他头文件</h4><ul>
<li>引入有必要的头文件，防止耦合。</li>
<li>当只需要知道这个类名，而不需要使用到里面的一些方法，我们可以使用向前声明的方式代替<code>#import</code>方案。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//向前声明</span><br><span class="line">@class someClass;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在各自的头文件里引入对方的头文件，虽然不会像C++那样导致死循环，但是会导致某个类无法被正确编译。</li>
</ul>
<h4 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h4><ul>
<li>什么是字面量语法？</li>
</ul>
<p>以一种简洁的方式就可以创建对象的方法，而不需要使用<code>alloc</code>和<code>init</code>来分配内存并进行初始化。并且除了字符串以外，所创建的对象必须属于Foundation框架。</p>
<p>example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *someString = @&quot;the String&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>字面量的各种例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//字面量字符串</span><br><span class="line">NSString *someString = @&quot;the String&quot;;</span><br><span class="line"></span><br><span class="line">//字面量数值</span><br><span class="line">NSNumber *intNumber = @1;</span><br><span class="line">NSNumber *floatNumber = @1.5;</span><br><span class="line"></span><br><span class="line">//字面量数组</span><br><span class="line">NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;];</span><br><span class="line">NSString *dog = animals[1];</span><br><span class="line"></span><br><span class="line">//字面量字典</span><br><span class="line">NSDictionary *personData = @[@&quot;firstName&quot; : @&quot;Matt&quot;,</span><br><span class="line">                              @&quot;lastName&quot; : @&quot;Gallway&quot;,</span><br><span class="line">                                   @&quot;age&quot; : @25];</span><br><span class="line">NSString *firstName = personData[@&quot;firstName&quot;];</span><br></pre></td></tr></table></figure>
<ul>
<li>使用字典或者数组的时候，如果值中有nil，则会抛出异常。</li>
</ul>
<h4 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h4><ul>
<li>由于Objective-C里没有命名空间的概念，所以如果使用预处理指令放在头文件里，那么引入该头文件的所有相关属性都会被替换，当常量名称可能冲突的时候，就可能存在一些隐藏的bug。</li>
<li>尽量不要在头文件里声明常量，应该在实现的代码里去声明。同时为了防止占用系统的命名空间，通常每个工程对常量的命名都有自己的命名规范，一般在前面加k。</li>
</ul>
<p>example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//  EOCAnimatedView.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCAnimatedView : UIView</span><br><span class="line"></span><br><span class="line">- (void)animate;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//  EOCAnimatedView.m</span><br><span class="line"></span><br><span class="line">#import &quot;EOCAnimatedView.h&quot;</span><br><span class="line"></span><br><span class="line">static const NSTimeInterval kAnimationDuration = 0.3;</span><br><span class="line"></span><br><span class="line">@implementation EOCAnimatedView</span><br><span class="line"></span><br><span class="line">- (void)animate &#123;</span><br><span class="line">    [UIView animateWithDuration:kAnimationDuration animations:^&#123;</span><br><span class="line">        //dosomething()</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一定要用const和static来同时修饰该常量，const表示不可被修改，而static则意味着该变量仅在定义此变量的编译单元可见。</p>
<ul>
<li>可以定义一个常量为其他文件所用，此类常量通常放在“全局符号表”中。</li>
</ul>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//header file</span><br><span class="line">extern NSString *const EOCStringConstant;</span><br><span class="line"></span><br><span class="line">//implementation file</span><br><span class="line">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</span><br></pre></td></tr></table></figure>
<p>编译器看到<code>extern</code>关键字，就知道在全局符号表里有一个名为<code>EOCStringConstant</code>的符号，编译器无需查看定义，允许代码使用，因为链接成二进制文件后可以找到这个常量。</p>
<h4 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h4><ul>
<li>一般情况下，编译器会为枚举分配一个独有的编号，从0开始，每次递增1。</li>
<li>建议使用如下方式来声明枚举：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, EOCConectionState) &#123;</span><br><span class="line">    EOCConectionStateDisConnected, //default 0</span><br><span class="line">    EOCConectionStateConnecting, //default 1</span><br><span class="line">    EOCConectionStateConnected //default 2</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>是这样在使用的时候就可以直接使用<code>EOCConectionState</code>作为类型进行声明枚举。其实<code>EOCConectionState</code>本质就是<code>NSUInteger</code>。</p>
<ul>
<li>枚举的命名应当通俗易懂，意义区分明显，不要出现混淆的情况。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2799
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/09/effective-Objective-C-2-0-总结与笔记（第一章）/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/06/07/day10-ios学习日记/">day10:ios学习日记</a>  
	       
		 

		 <time>2018-06-07 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day10: ios学习日记</p>
<p>第21章</p>
<ul>
<li><p>Core Data是一个可以管理模型对象之间关系的框架，可以保存或者读取一部分数据，它会管理这些对象的生命周期，并且更新对象之间的关系。Core Dkata能够在保存/加载对象的时候保持对象的一致性。Core Data会把对象保存在SQLite数据库中。</p>
</li>
<li><p>可变属性：当不存在于Core Data的类型，可以选择可变类型<code>transformable</code>，Core Data可以将对象转换成可存储的内容，然后读取时再转换回来。利用NSValueTransformer来进行转换。</p>
</li>
<li><p>生成NSManagedObject 的子类的时候，xcode8会默认在缓存文件中生成，如果需要自己手动生成的话，需要将codegen改成Manual/None。</p>
</li>
<li><p>navigation的时候，App的初始化一般是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rootViewController = window!.rootViewController <span class="keyword">as</span>! <span class="type">UINavigationController</span></span><br><span class="line"><span class="keyword">let</span> photosViewController = rootViewController.topViewController <span class="keyword">as</span>! <span class="type">PhotoViewController</span>(一开始显示在桌面的controller)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Core Data Stack是由实体相关的类和描述实体如何读/写的模型文件组成，模型文件可以使用NSManagedObjectModel对象表示。</p>
</li>
<li><p>Core Data的几种数据类型</p>
<p>|  SQLite   | 数据使用SQLite数据库保存到硬盘上（通常方法） |<br>| :——-: | :———————–: |<br>|  Atomic   |      数据使用二进制格式存储到硬盘上      |<br>|    XML    |          ios上不支持          |<br>| In-Memory |       保存在内存中而不是硬盘中        |</p>
<p>对象图和数据之间是通过<code>NSPersistentStoreCoordinator</code>对象来管理的。</p>
<p>创建<code>NSPersistentStoreCoordinator</code>对象，需要创建url，然后创建NSPersistentStoreCoordinator对象，创建了coordinator之后，需要指定一个store，运行时，store需要知道存储类型和数据存储的位置。</p>
</li>
<li><p>NSManagedObjectContext是与一个指定的NSPersistantCoordinator相关。NSManagedObjectContext的作用：</p>
<ul>
<li>当需要获取对象的时候，NSManagedObjectContext会通过NSPersistentStoreCoordinator把数据拷贝到内存中。</li>
<li>当需要保存对象的时候，可以调用NSManagedObjectContext的保存方法将数据保存到文件中。当调用保存方法之前，文件系统中的数据还是之前的数据。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> mainQueueContext : <span class="type">NSManagedObjectContext</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span>  moc = <span class="type">NSManagedObjectContext</span>(concurrencyType: .mainQueueConcurrencyType)</span><br><span class="line">    moc.persistentStoreCoordinator = <span class="keyword">self</span>.persistentStoreCoordinator</span><br><span class="line">    moc.name = <span class="string">"Main Queue Context (UI Context)"</span></span><br><span class="line">    <span class="keyword">return</span> moc</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据之后，需要把数据放入NSManagedObjectContext中，保存修改需要去监测NSManagedObjectContext是否有改变，当发生改变了之后，需要调用save函数。</p>
</li>
<li><p>要从NSMangedObjectContext中获取保存的数据，需要创建一个NSFetchRequest对象，获取请求执行之后，会得到符合请求参数的对象数组。利用NSPredicate来创建请求，然后借助sortDescriptors来实现排列顺序，最后通过NSMangedObjectContext来创建请求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchMainQueuePhotots</span><span class="params">(predicate: NSPredicate? = <span class="literal">nil</span>, sortDscriptors : [NSSortDescriptor]? = <span class="literal">nil</span> )</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Photo</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> fetchRequest = <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: <span class="string">"Photo"</span>)</span><br><span class="line">        fetchRequest.sortDescriptors = sortDscriptors</span><br><span class="line">        fetchRequest.predicate = predicate</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> mainQueueContext = <span class="keyword">self</span>.coreDataStack.mainQueueContext</span><br><span class="line">        <span class="keyword">var</span> mainQueuePhotos : [<span class="type">Photo</span>]?</span><br><span class="line">        <span class="keyword">var</span> fetchRequestError : <span class="type">Error</span>?</span><br><span class="line">        mainQueueContext.performAndWait() &#123;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="comment">//mainQueuePhotos = try mainQueueContext.execute(fetchRequest) as? [Photo]</span></span><br><span class="line">                mainQueuePhotos = <span class="keyword">try</span> mainQueueContext.fetch(fetchRequest) <span class="keyword">as</span>? [<span class="type">Photo</span>]</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">                fetchRequestError = error</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> photos = mainQueuePhotos <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> fetchRequestError!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> photos</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在硬盘上保存数据。利用imageStore类（在Homepwner中实现过的），来在照片存储类中添加一个容器，用来保存数据。</p>
</li>
</ul>
<p>第22章</p>
<ul>
<li><p>DataSource类: 实现UITableViewDataSource方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CoreData</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagDataSource</span> : <span class="title">NSObject</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tags : [<span class="type">NSManagedObject</span>] = []</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tags.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"UITableViewCell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> tag = tags[indexPath.row]</span><br><span class="line">        <span class="keyword">let</span> name = tag.value(forKey: <span class="string">"name"</span>) <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        cell.textLabel?.text = name</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加展示UIAlertController，即弹出对话框:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">addNewTag</span><span class="params">(sender : AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Add a Tag"</span>, message: <span class="literal">nil</span>, preferredStyle: .alert)</span><br><span class="line">    alertController.addTextField(configurationHandler: &#123;</span><br><span class="line">        (textField) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        textField.placeholder = <span class="string">"tag name"</span></span><br><span class="line">       <span class="comment">// textField.autocapitalizationType =</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"ok"</span>, style: .<span class="keyword">default</span>, handler: &#123;</span><br><span class="line">        (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tagName = alertController.textFields?.first?.text &#123;</span><br><span class="line">            <span class="keyword">let</span> context = <span class="keyword">self</span>.store.coreDataStack.mainQueueContext</span><br><span class="line">            <span class="keyword">let</span> newTag = <span class="type">NSEntityDescription</span>.insertNewObject(forEntityName: <span class="string">"Tag"</span>, into: context)</span><br><span class="line">            newTag.setValue(tagName, forKey: <span class="string">"name"</span>)</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="keyword">self</span>.store.coreDataStack.saveChanges()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"core data save failed :<span class="subst">\(error)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.updateTags()</span><br><span class="line">            <span class="keyword">self</span>.tableView.reloadRows(at: [<span class="type">IndexPath</span>.<span class="keyword">init</span>(index: <span class="number">0</span>)], with: .automatic)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    alertController.addAction(okAction) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cancelAction = <span class="type">UIAlertAction</span>(title: <span class="string">"cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>)</span><br><span class="line">    alertController.addAction(cancelAction)</span><br><span class="line">    present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父子NSManagedObjectContext，不能在主线程中计算大量的工作，否则会阻塞主线程，导致应用无法响应。通常使用多个NSManagedObjectContex。</p>
<p>定义一个后台线程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> privateQueueContext : <span class="type">NSManagedObjectContext</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> moc = <span class="type">NSManagedObjectContext</span>(concurrencyType: .privateQueueConcurrencyType)</span><br><span class="line">    moc.parent = <span class="keyword">self</span>.mainQueueContext</span><br><span class="line">    moc.name = <span class="string">"primary private queue context"</span></span><br><span class="line">    <span class="keyword">return</span> moc</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		4478
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/06/07/day10-ios学习日记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/06/07/day9-ios学习日记/">day9:ios学习日记</a>  
	       
		 

		 <time>2018-06-07 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day9:ios学习日记</p>
<p>第19章</p>
<p>这一章好难啊，感觉看了快一天，而且熟练度不够，需要再重新仔细看代码才行。</p>
<ul>
<li><p>利用URL的键值对来访问请求信息。可以利用枚举来建立响应的方法，方便后面进行使用。</p>
</li>
<li><p>在swift中，关于访问控制有三种:</p>
<p>| public         | internal                   | private                |<br>| ————– | ————————– | ———————- |<br>| 所有文件，包括第三方库的文件 | 默认值，对于app来说，只有当前项目的文件可以访问。 | 只有当前文件可以访问这个类，而不是当前的类。 |</p>
</li>
<li><p>闭包是很神奇的东西，不过由于见的比较少，在重新查看并通过一个例子之后终于理解了逃逸闭包的使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">逃逸闭包:当函数执行结束后,才去调用函数内部的闭包,叫做逃逸闭包</span><br><span class="line">非逃逸闭包:当函数执行过程中,执行的函数内部的闭包,叫做非逃逸闭包,默认情况下，是非逃逸闭包。</span><br><span class="line">-如果函数的最后一个参数是闭包,函数参数可以提前结束,最后一个参数直接使用&#123;&#125;,包装闭包的代码。</span><br></pre></td></tr></table></figure>
<p>例如这一段代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  Test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by gdgd on 18/5/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018年 gdgd. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        loadData &#123; (json: [<span class="type">String</span>]) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(json)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setupUI &#123; (result) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadData</span><span class="params">(completion:@escaping <span class="params">(<span class="number">_</span> : [String])</span></span></span>-&gt;()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"当前的线程<span class="subst">\(Thread.current)</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> json = [<span class="string">"lausen"</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"当前的线程<span class="subst">\(Thread.current)</span>"</span>);</span><br><span class="line">                </span><br><span class="line">                completion(json)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"执行到这儿结束了"</span>) <span class="comment">//函数结束后才去调用的闭包这个就是逃逸闭包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span><span class="params">(completion: <span class="params">(<span class="number">_</span> : [String])</span></span></span> -&gt; ()) &#123; <span class="comment">//而这个就是非逃逸闭包</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> json = [<span class="string">"liuxiang"</span>,<span class="string">"lausen"</span>,<span class="string">"somnus"</span>]</span><br><span class="line">        </span><br><span class="line">        completion(json)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前一直对于闭包作为参数有了一定的误会，以为在定义逃逸闭包的时候，就已经决定了他要做什么事情，但其实是在调用<strong>具有该闭包的参数的函数</strong>的时候，才会具体去实现闭包的具体内容。例如在这个例子中，虽然在逃逸闭包的定义里有一些输出，例如输出当前线程什么的，但是逃逸闭包的具体实现是在<code>viewDidLoad</code>里调用<code>loadData</code>的时候，对获得到到json数据，进行输出。最后输出结果为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"liuxiang"</span>, <span class="string">"lausen"</span>, <span class="string">"somnus"</span>]</span><br><span class="line">当前的线程&lt;<span class="type">NSThread</span>: <span class="number">0x608000071980</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;)</span><br><span class="line">执行到这儿结束了</span><br><span class="line">当前的线程&lt;<span class="type">NSThread</span>: <span class="number">0x600000065a00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">[<span class="string">"lausen"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>URLSession提供了和服务器进行通信的方法，其中URLSessionTask负责与服务器进行通信。URLSessionTask分为三种任务：数据任务、下载任务、上传任务。</p>
</li>
<li>捋一捋程序的思路：发送请求到服务器 -&gt; 获取JSON数据 -&gt; 构建解析JSON数据的模型 -&gt; 利用JSONSerialization来把数据转换成为基础对象即已定义的解析JSON数据的模型 -&gt; 将成功转换的数据转换成为Image对象显示出来。</li>
<li>默认情况下，由于访问网络时间可能很久，所以URLSessionTask在后台线程中运行，而更新UI需要在主线程，即<code>OperationQueue.main.addOperation</code></li>
</ul>
<p>第20章</p>
<ul>
<li><p>定义数据源，遵循UICollectionViewDataSouce协议的同时，也需要遵循NSObjectProtocol，可以采用直接继承NSObject类来实现。一定要实现的方法为:<code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell</code>和  <code>func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int</code> </p>
<p>一个是查询需要显示多少数据，另一个是用来获取指定位置的UICollectionViewCell。</p>
</li>
<li><p>使用扩展可以对自定义的类或者系统框架的类中添加方法，类、结构体和枚举都支持扩展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">calss <span class="type">A</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">A</span>: <span class="title">Equatable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> == <span class="params">(leftvar:A, rightvar: B)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftvar.a  == rightvar.a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2501
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/06/07/day9-ios学习日记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/06/06/day8-ios学习日记/">day8:ios学习日记</a>  
	       
		 

		 <time>2018-06-06 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day8:ios学习笔记</p>
<p>第17章</p>
<ul>
<li><p>UIView是UIResponder的子类，我们可以直接通过覆盖以下4个函数来处理触摸事件，即可完成画图的工作，当应用某个触摸事件发生后，系统都会将该事件添加至一个由UIApplication单例管理的事件队列中，然后UIApplication会向拥有该事件的视图发送特定的UIResponder消息。当多个手指在同一视图、同一时刻执行相同的触摸操作的时候，会采用单个消息、一次分发所有相关的UITouch对象的方式。注意：在这个例子中，不需要也不应该去保存UITouch对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesCancelled</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体和类的区别：</p>
<ul>
<li>结构体不支持继承</li>
<li>如果没有定义构造方法，结构体默认由一个根据成员生成的构造函数。</li>
<li>如果所有属性都有默认值，并且没有定义其他构造方法，结构体会有默人的一个空构造方法来创建结构体并设置默认值。</li>
<li>结构体是值类型的，而类是指针类型的。</li>
</ul>
</li>
<li><p>重载drawRect的时候，进行画图操作，当添加新线之后，调用setNeedDisplay()函数来进行调用drawRect。</p>
</li>
<li><p>利用IBInspectable来让代码中的属性和Interface Builder的属性相关联。</p>
</li>
<li><p>UIResponder对象可以成为第一响应对象并接受触摸事件，例如UIView,UIViewController,UIApplication,UIWindow。UIResponder对象有一个nextResponder()对象，这些对象一起组成了响应链。当UIResponder不处理某个事件时，就会把这个事件传递给nextResponder()方法，如果最终的UIApplication也没有处理这个事件，那么这个事件就会被忽略。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应链顺序：</span><br><span class="line"><span class="type">UIView</span> -&gt; father <span class="type">UIView</span> -&gt; <span class="type">UIViewController</span> -&gt; <span class="type">UIWindow</span> -&gt; <span class="type">UIApplication</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>UIControl是Cocoa Touch中很多类的父类，它不会直接向目标对象发送消息，而是通过UIApplication对象来进行转发。例如UIButton对象，要处理其事件的时候，是先通过UIControl的方法先对其是那种类型事件进行判断，然后再调用自身的sendActionsForControlEvents(_:)方法去查询目标动作对来进行匹配。如果UICtrol对象直接向目标对象发送消息，由于UIControl的目标－动作对中，可能目标对象为nil的情况，而通过UIApplication来转发会先进行判断对象是否为nil，如果是nil，那么UIApplication就会找出UIWindow对象的第一响应对象发送响应的动作消息。UIApplication对象是应用程序的象征，一个UIApplication就是一个应用程序，是以单例模式存在。</p>
</li>
</ul>
<p>第18章</p>
<ul>
<li><p>UIGestureRecognizer有很多子类，例如UITapGestureRecognizer,UILongPressGestureRecognizer 等，利用这些子类能够处理不同的手势。</p>
</li>
<li><p>delaysTouchesBegan，设置属性为true的时候，能够使得该手势延迟调用TouchBegan函数。</p>
</li>
<li><p>gesture1.require(toFail: gesture2 )能够使得gesture1在gesture2识别失败后再进行识别。</p>
</li>
<li><p>location(in:view)可以获取手势的位置。</p>
</li>
<li><p>一个应用只有一个UIMenuController，当需要展示他的时候，给他设置UIMenuItem,设置显示区域，设置可见即可。为了让其显示，需要将当前的View设置成第一响应对象，即重载<strong>变量</strong>canBecomeFirstResponder ,变量也可以进行重载！然后在显示menu之前，调用becomeFirstResponder()，再添加Item，设置显示区域，设置可见即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> canBecomeFirstResponder: <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将UIGestureRecognizer的cancelsTouchesInView属性设置成false，即可确保手势处理触摸事件后视图仍然可以通过UIResponder方法收到触摸事件。</p>
</li>
<li><p>当一个手势识别成功需要去识别另一个手势的时候，可以重载委托的这个函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gestureRecognizer</span><span class="params">(<span class="number">_</span> gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手势一共有7种状态:</p>
<p>|     状态      |                    意义                    |<br>| :———: | :————————————–: |<br>|  .possible  |   手势识别器还没有识别它的手势，但是可能正在评估触摸事件。这是默认状态。    |<br>|   .failed   | 手势识别器已经接收到不能识别为其手势的多点触摸序列。没有发送动作消息，手势识别器被重置为.possible |<br>|   .began    | 手势识别器已经接收到被识别为连续手势的触摸物体。它在运行循环的下一个周期发送其动作消息（或消息）。 |<br>|  .changed   | 手势识别器已经接收到被识别为对连续手势的改变的触摸。它在运行循环的下一个周期发送其动作消息（或消息）。 |<br>|   .ended    | 手势识别器已经接收到被识别为连续手势结束的触摸。它在运行循环的下一个周期发送其动作消息（或消息），并将其状态重置为.possible |<br>| .cancelled  | 手势识别器已经接收到触摸，从而导致连续手势的取消。它在运行循环的下一个周期发送其动作消息（或消息），并将其状态重置为.possible |<br>| .recognized | 手势识别器已经接收到它识别为手势的多点触摸序列。它在运行循环的下一个周期发送其动作消息（或消息），并将其状态重置为.possible |</p>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2784
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/06/06/day8-ios学习日记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/05/25/day7-ios学习笔记/">day7:ios学习笔记</a>  
	       
		 

		 <time>2018-05-25 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>第15章</p>
<ul>
<li><p>固化是由ios sdk提供的一种保存和读取对象的机制，固化某个对象的时候，会将该对象的所有属性存入指定的文件中，解固某个对象的时候，会从制定的文件中读取相应的数据，然后根据数据还原对象。</p>
</li>
<li><p>为了实现固化和解固，相应对象的类需要遵循NSCoding协议，其中有两个必须要实现的方法：encodeWithCoder(_: )和init(coder: )。</p>
</li>
<li><p>NSCoder会将要固化的类转换成键值对的形式写入指定的文件中。</p>
</li>
<li><p>每个应用都有自己的应用沙盒，应用的数据都存储在应用沙盒中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Documents</span>/ 		存储应用产生的需要保存的数据，可以进行备份。</span><br><span class="line"><span class="type">Library</span>/<span class="type">Caches</span>/ 	存储临时数据，保存在本机中，即应用缓存，不会备份。</span><br><span class="line"><span class="type">Library</span>/<span class="type">Perferences</span> 	存放应用设置和<span class="type">NSUserdefaults</span>的数据，会同步。</span><br><span class="line">tmp/ 	存放临时数据，应用没有运行的时候可以进行清除。</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件URL的demo如下：urls(for:in:)这个函数是用来在用户文件夹中查找相应的文件夹，在IOS中，in里的参数都是使用.userDomainMask，然后选择找到的第一个文件夹，然后在其中创建一个叫做”items.archive”的文件，注意是appending不是append，查阅api文档可以得知appendingPathComponent是有返回参数的，而appendPathComponent只是单纯的动作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z    <span class="keyword">let</span> itemArchiveURL : <span class="type">URL</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> documentsDirectories = <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask)</span><br><span class="line">        <span class="keyword">let</span> documentDirectory = documentsDirectories.first!</span><br><span class="line">        <span class="keyword">return</span> documentDirectory.appendingPathComponent(<span class="string">"items.archive"</span>)</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了保存应用的信息，可以调用NSKeyedArchiver.archiveRootObject(obj, to File:)，这段代码能够将要保存的对象存放到目标文件中，具体到原理是利用同一个NSKeyedArchiver对象作为参数，来让所有的对象(已经实现了NSCoding协议)发送encodeWithCoder消息，而每一个对象也会向其子对象发送该参数并发送encodeWithCoder消息。当所有对象完成编码后，NSKeyedArchiver对象会将数据写入文件中。这也是固化的过程了。</p>
</li>
<li><p>每个类（包括自己建立）都有一个初始化方法，一般情况下，为了加载已经存储的数据，可以利用解固的方式: 借助NSKeyedUnarchiver来实现，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> archivedItems = <span class="type">NSKeyedUnarchiver</span>.unarchiveObject(withFile: itemArchiveURL.path) <span class="keyword">as</span>? [<span class="type">Item</span>] &#123;</span><br><span class="line">            allItems += archivedItems</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用切换的时候，app的状态切换如下所示，即调用AppDelegate中的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打开应用，会调用: application(<span class="number">_</span>:didFinishLaunchingWithOptions:)和applicationDidBecomeActive</span><br><span class="line">按下home键，会调用: applicationWillResignActive和applicationDidEnterBackground</span><br><span class="line">重新回到应用，会调用:applicationWillEnterForeground和applicationDidBecomeActive</span><br><span class="line">双击home键到切换应用界面类似按下home键的操作。</span><br><span class="line">按下锁屏，会调用:applicationWillResignActive和applicationDidEnterBackground</span><br><span class="line">在切换应用界面将应用终止，系统会终止应用，但应用的委托对象不会收到任何信息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>guard能够让代码更简洁，让方法在不满足条件的时候提前跳出，只有当表达式为true的时候，才会执行表达式，具体语法为: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> expression <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误处理代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> throwing expression</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第16章</p>
<p>为了在不同的界面显示不同的内容，即适配横屏和竖屏，我们需要专门定制某个界面。</p>
<ul>
<li>SizeClass有四种组合，可以在main.storyboard中直接进行预览。</li>
<li>定制特定的视图的时候，可以在对应部件中设置显示条件。</li>
<li>如果是要改上下布局为左右布局，可以将整体放在UIStackView中，更方便进行操作。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2091
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/05/25/day7-ios学习笔记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/05/25/day6-ios学习笔记/">day6:ios学习笔记</a>  
	       
		 

		 <time>2018-05-25 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>第13章</p>
<ul>
<li>利用UINavigationController来实现顶部栏，从而实现ios各个界面之间的切换。其实现原理是在UINavigationController维护一个UIViewController数组，而显示在屏幕上的是位于栈顶的元素。</li>
<li>设置一个初始的UIViewController对象为UINavigationController的根视图控制器。根视图控制器将永远位于栈底。</li>
<li>UINavigationController是UIViewController的子类，所以在main.storyboard里也是一个视图对象，该对象有两个子视图，一个是UINavigationController，另一个是栈顶元素的View。压栈操作会自动完成，无需用户手动设置，仅需设置跳转即可。</li>
<li>使用UINavigationController的方式就是为其设置一个根视图控制器即可。同时一般情况下，需要在应用委托里，将UINavigationController设置为window的根视图控制器。</li>
<li>切换视图更新数据，消失的视图会调用viewWillDisappear(_ :)，而出现的视图会调用viewWillAppear(_ :)，由于DIP原则，可以在这两个函数中去进行数据传递。在viewWillDisappear里更新数据，在viewWillAppear让数据显示在屏幕上。</li>
<li>第一响应者状态：对于键盘事件和摇晃事件，有些响应没有位置等相关信息，不能用位置来决定哪些视图接受事件，就需要第一响应者事件。同一时刻只有一个第一响应者。例如在UITextField和UITextView中，当触摸事件被触发，UITextField和UITextView成为第一响应者，让系统在屏幕上显示键盘。所以要取消键盘可以使用resignFirstResponder函数来实现。要监管键盘等输入做出响应也需要使用委托机制。</li>
<li>在main.storyboard中添加手势控件的时候，需要注意绑定到了哪个视图，否则可能会达不到预期的效果。</li>
<li>每个UIViewController都有一个navigationItem属性，这并不是一个UIView的子类，如果已经通过Interface Builder设置了一个之后，再需要设置的话就需要通过代码设置。</li>
</ul>
<p>第14章</p>
<ul>
<li><p>利用UIImagePickerController对象的时候，需要为新创建的对象设置sourceType属性和delegate属性。利用isSourceTypeAvailable来进行类型判断。</p>
</li>
<li><p>为UIImagePickerController对象设置委托还需要实现UINavigationControllerDelegate协议，因为UIImagePickerController的委托属性是从UINavigationController中继承的。先设置该对象的委托为self（为什么？），然后利用present的方式，以模态的形式显示。</p>
</li>
<li><p>根据DIP原则，为了保存图片，我们可以创建一个ImageStore类来实现。具体代码可能和第五版的书有些出入，具体为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = <span class="type">NSCache</span>&lt;<span class="type">AnyObject</span>, <span class="type">AnyObject</span>&gt;() <span class="comment">//创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(image: UIImage, forKey key: String)</span></span>&#123;</span><br><span class="line">        cache.setObject(image, forKey: key <span class="keyword">as</span> <span class="type">AnyObject</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imageForKey</span><span class="params">(key: String)</span></span> -&gt; <span class="type">UIImage</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.object(forKey: key <span class="keyword">as</span> <span class="type">AnyObject</span>) <span class="keyword">as</span>? <span class="type">UIImage</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">deleteImageForKey</span><span class="params">(key: String)</span></span>&#123;</span><br><span class="line">        cache.removeObject(forKey: key <span class="keyword">as</span> <span class="type">AnyObject</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过这次实验也更好的理解了<code>as!</code>和<code>as?</code>的使用，明白了为什么需要使用<code>as?</code>，例如在上述例子中，由于可能存在对象不存在的情况，所以使用<code>as?</code>的方式来让返回的对象可选。而<code>as!</code>则是在返回的时候强制解包，前提需要能保证其不为空。</p>
</li>
<li><p>为了要让照片能被存储，其实并不是在Item类里存放一个UIImage对象，而是存放一个String类型的对象，然后通过NSCache这个类来进行映射。为了能够在两个页面都得到响应的信息，需要在两个页面都放变量imageStore，并且在AppDelegate.swift中创建该对象。然后在两个页面同时维护一个对象。</p>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		1927
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/05/25/day6-ios学习笔记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/05/24/day5-ios学习笔记/">day5:ios学习笔记</a>  
	       
		 

		 <time>2018-05-24 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>第11章：</p>
<ul>
<li><p>通过创建UITableViewCell的对象来自定义列表类型。</p>
</li>
<li><p>可以用这段代码来实现让用户滑动UITableView后菜计算每行的高度，从而减少延迟，提高性能。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></span><br><span class="line">tableView.estimatedRowHeight = <span class="number">65</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用prefreredFontForTextStyle可以实现同步更新字体。具体步骤是先在Main.storyboard里将Label的Font进行修改。</p>
</li>
<li>主要是实用tableView函数来进行对cell进行修改。</li>
</ul>
<p>第12章：</p>
<ul>
<li>UIStackView具有垂直和水平的结构，可以对Stack中的栈的部件进行嵌入操作可以将该部件嵌入到一个新的UIStackView中。</li>
<li>内容变多优先级(content hugging priorities)和内容抗压优先级(content compression resistance priorities)是视图的隐藏约束。视图的每个方向都有一个这样的优先级。优先级取值为0-1000。<ul>
<li>内容变多优先级：优先级越高的视图不会拉伸，而优先级低低则会拉伸，可以去降低某个视图的优先级实现该视图的拉伸。</li>
<li>内容抗压优先级：当视图大小<strong>小于</strong>内部大小的时候，内部抗压优先级高的视图更能抵抗压缩，即不省略文字。</li>
</ul>
</li>
<li>segues：是可以把另一个UIViewController的视图加到屏幕上。它决定了UIViewController的展示方式。可以通过从main.storeboard直接拉到swift文件中进行创建对象。可以重载viewWillAppear函数进行对自定义cell的部件更新。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		729
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/05/24/day5-ios学习笔记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/05/23/day4-ios学习笔记/">day4:ios学习笔记</a>  
	       
		 

		 <time>2018-05-23 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day4:ios学习笔记</p>
<p>今天主要是学习了一个动画的demo和关于UITableView的使用。</p>
<p>第八章：</p>
<ul>
<li><p>闭包，语法如下，但是什么时候用闭包啊什么的，因为接触的较少，还不能很好的去应用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (arguments)-&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动画使用animateWithDuration函数来实现，其中animations和completitions参数都是闭包类型。</p>
</li>
<li><p>约束也可以作为变量进行绑定，在书中第八章的demo中，就是采用不断变更约束条件的方式去实现动画效果。</p>
</li>
<li><p>调用视图的layoutIfNeed()方法可以让系统根据最新的约束来布局视图，所以可以在animations的闭包中调用该方法。</p>
</li>
<li><p>options参数可以控制动画的时间参数。</p>
</li>
</ul>
<p>第九章：</p>
<ul>
<li><p>UITableViewController对象可以扮演UITableView交互中所涉及到的MVC模式中的三种对象，包括视图控制器对象、数据源和委托对象</p>
</li>
<li><p>应用启动的时候，AppDelegate的application(_:didFinishLaunchingWithOptions:)方法会被调用，AppDelegate是应用的委托，用来响应应用运行中的各种状态。</p>
</li>
<li><p>DIP原则(dependency inversion principle)，通过倒置依赖关系来解耦对象，让代码的可维护性提高。</p>
<ul>
<li>高层对象不依赖底层对象，依赖于抽象</li>
<li>抽象不依赖于细节，细节依赖抽象</li>
</ul>
</li>
<li><p>在使用UITableView的时候，必须要实现的两个方法为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取行数</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取每行所存放的数据</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个UITableViewCell都有textLabel、textDetail和Image 3个属性。</li>
</ul>
</li>
<li><p>要重用UITableViewCell，可以先设定Identifier，然后使用dequeueReusableCell来进行实现。</p>
</li>
<li><p>利用insets(边衬)，来实现布局的上左下右的间距。</p>
</li>
</ul>
<p>第十章</p>
<p>这一章看下来反而觉得难度不大，但是主要还是知识储备不够，很多时候不知道要用什么东西。</p>
<ul>
<li><p>提示框弹窗代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="string">"balabala"</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"balabala"</span></span><br><span class="line"><span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: title, message: message, preferredStyle: .actionSheet)<span class="comment">//还有.alert类型</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="type">UIAlertAction</span>(title: <span class="string">"cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>)<span class="comment">//do nothing</span></span><br><span class="line"><span class="keyword">let</span> done = <span class="type">UIAlertAction</span>(title: <span class="string">"done"</span>, style: .destructive, handler: &#123;</span><br><span class="line">    (action)-&gt;<span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br><span class="line">ac.addAction(cancel)</span><br><span class="line">ac.addAction(done)</span><br><span class="line">present(ac,animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>) <span class="comment">//make it work</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于DIP模式有了更好的理解，为了完成这个例子，我们是通过对ItemStore这个类去增加功能性函数，而非在自定义的controller里面去实现，那么TableViewController其实只是知道自己有这样一个ItemStore类型的对象，但是具体实现什么我们可以在ItemStore类中进行实现和修改。即高层依赖于抽象，细节依赖于抽象。</p>
</li>
</ul>
<p>- </p>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		1712
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/05/23/day4-ios学习笔记/">Continue</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/05/23/day3-ios学习笔记/">day3:ios学习笔记</a>  
	       
		 

		 <time>2018-05-23 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day3:IOS学习笔记</p>
<p>今天出去玩了，所以看了书但是实践和笔记没跟上，现在补一下。</p>
<p>第六章：</p>
<p>主要是利用代码来生成视图，并用代码建立约束</p>
<ul>
<li><p>在loadView中建立视图实例，并设置成rootView。</p>
</li>
<li><p>将translatesAutoresizingMaskIntoConstraints的属性设置为false可以使得根据添加的约束不会与storyboard中的约束冲突。</p>
</li>
<li><p>利用锚点可以实现代码的约束，锚点的有多个，主要是用<code>constraint</code>这个函数来实现，设置好之后，需要设置属性<code>isActive</code>为true。</p>
</li>
<li><p>addTarget函数的第二个参数，正确的使用是：<code>#selector(mapTypeChangec(segControl:))</code>，这里卡了很久很久，快半个小时才找到正确的传参方式。</p>
</li>
<li><p>创建多一个webView，具体代码为： 可以利用UIScreen这个类来实现获取屏幕宽度长度等信息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebViewController</span> : <span class="title">UIViewController</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> webView : <span class="type">UIWebView</span>!</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">       <span class="comment">// var viewBound : CGRect = UIScreen.main.bounds</span></span><br><span class="line">        webView = <span class="type">UIWebView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">20</span>, width:<span class="type">UIScreen</span>.main.bounds.width , height: <span class="type">UIScreen</span>.main.bounds.height-<span class="number">20</span>))</span><br><span class="line">        view.addSubview(webView)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> webStr : <span class="type">String</span> = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">        <span class="keyword">let</span> curUrl:<span class="type">NSURL</span> = <span class="type">NSURL</span>(string: webStr)!</span><br><span class="line">        <span class="keyword">let</span> request : <span class="type">NSURLRequest</span> = <span class="type">NSURLRequest</span>(url : curUrl <span class="keyword">as</span> <span class="type">URL</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        webView.loadRequest(request <span class="keyword">as</span> <span class="type">URLRequest</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第七章：</p>
</li>
<li><p>decimalSeparator = Locale.current.decimalSeparator! 代替书上的代码</p>
</li>
<li>国际化需要对每一个语言进行人工翻译，只需要配置好相应的文件，在区域化文件中进行修改字符串。</li>
<li>使用终端使用genstring时候，需要先配置环境，要找到xposed的安装路径中的developer文件夹作为配置环境。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/ios/">ios</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/ios/">ios</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		1078
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/05/23/day3-ios学习笔记/">Continue</a> 
    	
</article>     
     	
  

 

  <nav class="paginator scrollIn">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>
  


        </section> 

    </div>        

    
    
    <div id="backTop" class="iconfont icon-backtotop sildeUpMin"></div> 

    

        
        <div class="search-container sildeUpMin">
            <input type="text" placeholder="Typing Something here." id="search-input" class="search-input">  
              <span class="search-cancel iconfont icon-cancel"></span>
              <div id="search-result" class="search-result"></div>
        </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src= "/images/favicon.png" >   
      

         
            

            <a class="mobile-menu-link" href="/">Home
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">Archives
            </a>
            
         
            

            <a class="mobile-menu-link" href="/categories">Categories
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">Tags
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">About
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">Search </a>                 
            
         
      
</div>     


    <footer id="footer">
	   
   	 

	  	
   	
	   
      	 

	
	

	 <div>
	 	&copy;
				
		2017-
		
		2018			
	
		
		PengGuodong	 

	 </div>
	
   
   	 <div>
	
	 <a href="http://hexo.io/" target="_blank">Hexo</a>

	 Theme

	 <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a> 

	 </div>	


	
	
</footer>    
    

<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>





 
    
    
    <script src="/main.bundle.js"></script>        
  </body>        
</html>