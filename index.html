<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport"content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
  
  
  <title>  JellyP </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/style.min.css"> 
</head>  
  <body>   
    <header class="header">
	
  <nav class="header-nav">       
	
  	<span class="iconfont icon-menu mobile-toggle"></span>  

    <a class="header-logo" href="/"><span>JellyP</a>  

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-categories" href="/categories">分类</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>   

    <div class="container">       
      
        

          <section id="main">  

        

        


<div class="profile sildeUpMin">

	<img class="avatar" src="/images/header.jpg"  alt="No Avatar.">
					
		<p class="author">PengGuodong</p>

		
			<p class="location"><span class="iconfont icon-location"></span>GuangZhou CN</p>
		
	
		<div class="social">
   		   
   		<span data-hover="Github">
		<a class="iconfont icon-Github" target="_blank" href="https://github.com/JellyP" >		
		</a></span>
	    
    </div>		
</div>

      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/23/effective-Objective-C2-0总结与笔记-第六章/">Effective Objective-C 2.0 总结与笔记（第六章）—— 块与大中枢派发</a>  
	       
		 

		 <time>2018-11-23 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第六章：块与大中枢派发"><a href="#第六章：块与大中枢派发" class="headerlink" title="第六章：块与大中枢派发"></a>第六章：块与大中枢派发</h3><p>​    当前多线程编程的核心就是“块”和“大中枢派发”(Grand Central Dispatch,GCD)。块是一种可以在C、C++和Objective-C代码里使用的词法闭包，借用这种机制，开发者可以将代码像对象一样传递，令其可以在不同对象中运行，同时定义块的地方可以访问到其中的全部变量。</p>
<p>​    GCD是一种与块有关的技术，它提供了对线程的抽象，这种抽象基于派发队列(dispatch queue)。</p>
<h4 id="第37条：理解“块”这一概念"><a href="#第37条：理解“块”这一概念" class="headerlink" title="第37条：理解“块”这一概念"></a>第37条：理解“块”这一概念</h4><ul>
<li>块与函数类似，只不过是直接定义在另一个函数里的，和定义它的那个函数共享同一个范围内的东西。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//块用^的符号表示</span><br><span class="line">^&#123;</span><br><span class="line">    //Block implementation here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//块也是个值，也有其相关类型。块具有相关参数和返回值，例如下面这个块就是没有参数，也不返回值。</span><br><span class="line">void (^someBlock)() = ^&#123;</span><br><span class="line">    //Block implementation here</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//其语法特点就是</span><br><span class="line">return_type (^block_name)(parameters)</span><br><span class="line"></span><br><span class="line">//例如下面这个块定义了块返回int类型，接受2个int类型参数</span><br><span class="line">int (^addBlock)(int a, int b) = ^(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int add = addBlock(2,5);//add = 7</span><br></pre></td></tr></table></figure>
<ul>
<li><p>块的强大之处在于：在生命它的范围里，所有变量都可以被它捕获。默认情况下，为块所捕获的变量，是不可以在块内被修改的。如果在声明变量的时候，加上<code>__block</code>修饰符，这样就可以在块内修改了。</p>
</li>
<li><p>块的内部结构：</p>
<ul>
<li>在内存布局中，最重要的就是invoke变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个<code>void*</code>型的参数，此参数代表块。块其实就是一种代替函数指针的语法结构。</li>
<li>descriptor指针式指向结构体的指针，每个块都包含这个结构体，其中声明了块的总体大小，还声明了copy与dispose这两个辅助函数对应的函数指针。</li>
<li>块还会把它所捕获的对象都拷贝一份，放在descriptor变量后面。拷贝的并不是对象本身，而是指向这些对象的指针变量。</li>
</ul>
</li>
<li>全局块、栈块和堆块：块的内存区域是分配在栈中的，也就是只在定义它的那个范围内有效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void (^block)();</span><br><span class="line">if (/* some condition*/) &#123;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(&quot;Block A&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(&quot;Block B&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面这段代码看似没什么问题，但是由于定义在<code>if</code>和<code>else</code>语句中的两个块都分配在栈内存中，编译器会给每个块分配好栈内存，但是离开了相应的范围之后，编译器有可能把块的内存给覆写掉，于是这两个块只能保证在对应的<code>if</code>或者<code>else</code>语句范围内有效。</p>
<p>   为了解决这个问题，可以通过给块对象发送<code>copy</code>消息，让块从栈复制到堆，拷贝后的块，就可以在定义它的那个范围之外使用了，当复制到堆上后，块就成了带引用计数的对象了，后续再执行copy等于是增加引用计数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void (^block)();</span><br><span class="line">if (/* some condition*/) &#123;</span><br><span class="line">    block = [^&#123;</span><br><span class="line">        NSLog(&quot;Block A&quot;);</span><br><span class="line">    &#125; copy];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    block = [^&#123;</span><br><span class="line">        NSLog(&quot;Block B&quot;);</span><br><span class="line">    &#125; copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    还有一类块叫做全局块，这种块在编译器即可以确定，所以不会捕获任何状态，它可以声明在全局内存里，而不需要每次用到的时候在栈里创建，全局块的拷贝操作是个空操作，因为系统不会回收全局块。</p>
<h4 id="第38条：为常用的块创建typedef"><a href="#第38条：为常用的块创建typedef" class="headerlink" title="第38条：为常用的块创建typedef"></a>第38条：为常用的块创建typedef</h4><ul>
<li>由于块的定义语法非常难记和难懂，所以通常使用类型定义来简化块的定义。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//可以这样定义：</span><br><span class="line">typedef int(^EOCSomeBlock) (BOOL flag, int value);</span><br><span class="line">//表示向系统中新增了一个名为EOCSomeBlock的类型，以后再使用它就可以这样</span><br><span class="line">EOCSomeBlock block = ^(BOOL flag, int value) &#123;</span><br><span class="line">    //Implementation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义新类型应该遵循现有的命名规范，避免名称与别的类型冲突。</li>
<li>可以为同一个块签名定义多个类型别名，这样可以方便统一修改，同时也把代码解耦合。</li>
</ul>
<h4 id="第39条：用handler块降低代码分散程度"><a href="#第39条：用handler块降低代码分散程度" class="headerlink" title="第39条：用handler块降低代码分散程度"></a>第39条：用handler块降低代码分散程度</h4><ul>
<li>在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明。</li>
<li>在有多个实例需要监控的时候，如果使用委托模式，那么经常需要根据传入的对象来切换，若该用handler块来实现，则可以直接将块与相关对象放在一起。</li>
<li>设计API时如果用到了handler块，那么可以增加一个参数，让调用者可以通过此参数来决定应该把块安排在哪个队列上执行。</li>
</ul>
<h4 id="第40条：用块引用起所属对象的时候不要出现保留环"><a href="#第40条：用块引用起所属对象的时候不要出现保留环" class="headerlink" title="第40条：用块引用起所属对象的时候不要出现保留环"></a>第40条：用块引用起所属对象的时候不要出现保留环</h4><ul>
<li><p>如果块捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。</p>
<p>假如下面这个类提供了一套接口，调用者可由此从某个URL中下载数据，在启动获取器时，可以设置<code>completion handler</code>，这个块会在下载结束之后以回掉方式执行，为了能在下载完成后通过<code>p_requestCompleted</code>方法执行调用者制定的块，这段代码需要把<code>completion handler</code>保存到实例变量里。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">typedef void (^EOCNetworkFetcherCompletionHandler)(NSData *data);</span><br><span class="line"></span><br><span class="line">@interface EOCNetworkFetcher : NSObject</span><br><span class="line">@property (nonatomic, strong, readonly) NSURL *url;</span><br><span class="line">- (id)initWithURL:(NSURL *)url;</span><br><span class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCNetworkFetcher()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readwrite) NSURL *url;</span><br><span class="line">@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;</span><br><span class="line">@property (nonatomic, strong) NSData *downloadData;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCNetworkFetcher</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURL:(NSURL *)url</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _url = url;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</span><br><span class="line">&#123;</span><br><span class="line">    self.completionHandler = completion;</span><br><span class="line">    //Start the request</span><br><span class="line">    //Request sets downloadedData property</span><br><span class="line">    //When request is finished, p_requestCompleted is called</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)p_requestCompleted</span><br><span class="line">    &#123;</span><br><span class="line">    if (_completionHandler) &#123;</span><br><span class="line">        _completionHandler(_downloadData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>某个类可能会创建这种网络数据获取器对象，并用其从URL中下载数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@implementation EOCClass &#123;</span><br><span class="line">    EOCNetworkFetcher *_networkFetcher;</span><br><span class="line">    NSData *_fetchedData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)downloadData</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;www.qq.com&quot;];</span><br><span class="line">    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class="line"></span><br><span class="line">    [_networkFetcher startWithCompletionHandler:^(NSData *data) &#123;</span><br><span class="line">        _fetchedData = data;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这段代码存在一个保留环，因为<code>completion handler</code>块要设置<code>_fetchedData</code>实例变量，所以它必须捕获EOC的self对象，也就是handler块保留了创建<code>_networkFetcher</code>的那个EOClass实例，而EOCClass实例通过strong实例保留了<code>_networkFetcher</code>，最后块是属于<code>_networkFetcher</code>的。</p>
<p><img src="/2018/11/23/effective-Objective-C2-0总结与笔记-第六章/1.png" alt="1"></p>
<p>一般来说只需要适时清理掉环中的某个应用，即可解决问题，但是很可能没办法打破这种引用环，在这个例子里，只需要<code>completion handler</code>执行后，那么就可以解除保留环，如果<code>completion handler</code>一直不运行，那么保留环就无法打破，导致内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用完成后回收对象，打破保留环</span><br><span class="line">[_networkFetcher startWithCompletionHandler:^(NSData *data) &#123;</span><br><span class="line">    _fetchedData = data;</span><br><span class="line">    _networkFetcher = nil;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>还有一种保留环是<code>completion handler</code>块所引用的对象最终又引用了这个块本身，那么就会出现保留环。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadData</span><br><span class="line">&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;www.qq.com&quot;];</span><br><span class="line">    EOCNetworkFetcher *networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class="line"></span><br><span class="line">    [networkFetcher startWithCompletionHandler:^(NSData *data) &#123;</span><br><span class="line">        NSLog(@&quot;request Url %@ finished&quot;, networkFetcher.url);</span><br><span class="line">        _fetchedData = data;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>completion handler</code>块其实要通过获取器对象来引用其中的URL。于是，块就要保留获取器，而获取器反过来又经由其<code>completionHandler</code>属性保留了这个块。获取器对象之所以要把completionHandler块保存在属性里面，其唯一目的就是想稍后使用这个块。可是，获取器一旦运行过<code>completion handler</code>之后，就没有必要在保留它了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)p_requestCompleted</span><br><span class="line">&#123;</span><br><span class="line">    if (_completionHandler) &#123;</span><br><span class="line">        _completionHandler(_downloadData);</span><br><span class="line">    &#125;</span><br><span class="line">    self.completionHandler = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，只要下载请求执行完毕，保留环就解除了，而获取器对象也将会在必要时为系统所回收。</p>
<h4 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h4><ul>
<li><p>如果多个线程要执行同一份代码，通常要使用锁来实现同步机制，在GCD出现之前，一般有两种办法：</p>
<ul>
<li>使用内置的同步块。这种方式是针对某个对象自动创建一个锁，执行到这段代码的结尾处，那么锁就释放了，滥用同步锁的话会降低代码效率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sychronizedMethod &#123;</span><br><span class="line">    @sychronized(self) &#123;</span><br><span class="line">        //safe code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用NSLock对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[NSLock alloc] init];</span><br><span class="line">- (void)sychronizedMethod &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    //safe code</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有NSRecursiveLock这种递归锁，线程能够多次持有该锁，而不会出现死锁。</p>
</li>
<li><p>上面两种方法在极端情况下都会导致死锁，效率也不见得很高，遇到了死锁非常麻烦。而替代的方案就是GCD。</p>
<ul>
<li>如果自己编写原子性的访问方法，使用同步块可以这样写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)someString &#123;</span><br><span class="line">    @sychronized(self) &#123;</span><br><span class="line">        return _someString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">    @sychronized(self) &#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这样的做法无法保证绝对的线程安全，因为在同一个线程多次调用getter方法的时候，得到的结果未必相同，因为在两次访问操作之间，其他线程可能写入了新的值。</p>
<ul>
<li>使用GCD的串行同步队列，将读取和写入操作都放在同一个队列里，可以保证数据同步。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(&quot;com.gdgd.syncQueue&quot;, NULL);</span><br><span class="line">- (NSString)someString &#123;</span><br><span class="line">    __block NSString *localString;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        localString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    return localString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这种方法把设置操作与获取操作都安排在序列化的队列里执行，这样所有的属性的访问操作都同步了。还可以进一步优化，因为设置方法不需要同步，所以可以把设置方法改成异步的方法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">    dispatch_async(_syncQueue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这个小改动可以提升设置方法的执行速度，而读取和写入操作依然会按照顺序执行，但是由于执行异步派发需要拷贝块，所以可能导致性能下降，因为拷贝块的时间远大于执行块的时间。如果派发给队列的块更繁重的工作，这种方案是可以考虑的。</p>
<ul>
<li>由于多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，可以采用并发队列代替串行队列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString)someString &#123;</span><br><span class="line">    __block NSString *localString;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        localString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    return localString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">    dispatch_async(_syncQueue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这种方法暂时还无法实现同步，因为现在写入和读取操作可以随时执行。为了实现读取的时候可以并发，写入的时候串行，我们可以使用栅栏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_barrier_sync(dispatch_queue_t queue,</span><br><span class="line">		DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class="line">void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>​    在队列中，栅栏必须单独执行，不能与其他块一起执行，这只对并发队列有意义，如果并发队列发现接下来要执行的块是个栅栏块，那么就会一直等到当前所有的并发块执行完毕，再单独执行这个栅栏块，等栅栏块执行过后，再按正常方式继续处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString)someString &#123;</span><br><span class="line">    __block NSString *localString;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        localString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    return localString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">    dispatch_barriar_async(_syncQueue, ^&#123;</span><br><span class="line">        _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    使用这种方式，同步行为的效率更高。</p>
</li>
</ul>
<h4 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h4><ul>
<li><p>Objective-C本质上是一门非常动态的语言，NSObject定义了几个方法能够随意调用任何方法。甚至可以定义方法运行的线程，在GCD和块出现后，建议尽量少用这些方法。例如最简单的<code>performSelector:</code>方法，接受一个参数表示要执行的选择子，这种方法与直接调用选择子等效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[object performSelector:@selector(selectorName)];</span><br><span class="line">[object selectorName];</span><br></pre></td></tr></table></figure>
<p>上面的方式看不出来<code>performSelector</code>的妙用，但是如果在运行期决定的选择子，就能体现出该函数的强大之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEL selector;</span><br><span class="line">if (/* some condition */) &#123;</span><br><span class="line">    selector = @selector(foo);</span><br><span class="line">&#125;</span><br><span class="line">else if (/* some other condition */)&#123;</span><br><span class="line">    selector = @selector(bar);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    selector = @selector(baz);</span><br><span class="line">&#125;</span><br><span class="line">[object performSelector:selector];</span><br></pre></td></tr></table></figure>
<p>上面这种编程方式可以用来简化复杂的代码，但是这个特性的代价是在ARC下编译代码的话，就会导致内存警告，因为编译器不知道要调用的选择子是谁，因此也就不了解其方法签名和返回值，所以没办法运用ARC的内存管理规则来判定返回值是不是应该被释放，所以ARC为了安全，则会不添加释放操作，导致内存泄漏。</p>
</li>
<li><p>还有个原因在于：返回值只能是void或对象类型，尽管所要执行的选择子也可以返回void，但是<code>performSelector</code>方法的返回值类型毕竟是id，如果想要返回整数或浮点数等类型的值，就需要复杂的转换。同样，这种方法选择子最多只能接受两个参数，更多的参数就没有相应的方法可以执行。</p>
</li>
<li><p><code>performSelector</code>还可以延后执行选择子，或者放在另一个线程中执行，但是这些都有一定的局限性，例如要处理带有两个参数的选择子，就得把许多参数打包到字典里，然后在受调用的方法里取出来，这样很容易出bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure>
<p>例如要延后执行某个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//using performSelector</span><br><span class="line">[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];</span><br></pre></td></tr></table></figure>
<p>还可以使用GCD的<code>dispatch_after</code>来实现，这种方法更为合理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//using dispatch_after</span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">    [self doSomething];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h4><ul>
<li>在解决多线程的任务管理的时候，GCD并不是最佳方式，还有一种操作队列<code>NSOperationQueue</code>，虽然和GCD不同，但是与之相关，开发者可以把操作以<code>NSOperation</code>子类的形式放在队列中，这些操作也能并发执行。</li>
<li>操作队列和GCD有区别：<ul>
<li>GCD是纯C的api，而操作队列是Objective-C的对象。</li>
<li>GCD中任务用块来表示，操作队列使用Objective-C对象（更重）。</li>
</ul>
</li>
<li>用<code>NSOperationQueue</code>类的<code>addOperationWithBlock：</code>方法搭配<code>NSBlockOperation</code>类来使用操作队列，其语法和GCD方式类似。使用<code>NSOperation</code>和<code>NSOperationQueue</code>的好处如下：<ul>
<li>取消某个操作。GCD无法取消，但是操作队列可以很容易的取消某个任务。</li>
<li>制定操作间的依赖关系，一个操作可以依赖多个操作。比如使得特定的操作必须在另一个操作顺利执行完毕后方可执行。</li>
<li>通过键值观测机制监控<code>NSOperate</code>对象的属性。例如<code>isCancelled</code>属性来判断任务是否被取消，还有例如<code>isFinished</code>等关于任务状态的属性。</li>
<li>制定操作的优先级。可以设定操作队列中操作的优先级。GCD的队列也有优先级，不过是针对整个队列，而不是队列中的任务。</li>
<li>可以重用<code>NSOperation</code>对象，系统内置了一些<code>NSOperation</code>的子类供开发者调用。这些类就是普通的Objective-C对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，还可以随意调用定义在类中的方法。</li>
</ul>
</li>
</ul>
<h4 id="第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条：通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务</h4><ul>
<li>dispatch group是GCD的一项特性，能够创建任务分组，通过这种方式，调用者可以知道一组任务的结束时机。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//利用这个可以创建dispatch group</span><br><span class="line">dispatch_group_t dispatch_group_create();</span><br></pre></td></tr></table></figure>
<p>​    有两种方法给任务编组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_async(dispatch_group_t group,</span><br><span class="line">                          dispatch_queue_t queue,</span><br><span class="line">                          dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>​    以及使用一对函数来指定执行的块：这个和引用计数类似，成对出现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将分组里正要执行的任务数递增</span><br><span class="line">void dispatch_group_enter(dispatch_group_t group);</span><br><span class="line">//将分组里正要执行的任务数递减</span><br><span class="line">void dispatch_group_leave(dispatch_group_t group);</span><br></pre></td></tr></table></figure>
<p>​    要等待group的任务执行完成，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_group_wait(dispatch_group_t group,</span><br><span class="line">                         dispatch_time_t timeout);</span><br><span class="line">/**</span><br><span class="line">传入两个参数，等待的group和超时时间timeout，一般timeout取常量DISPATCH_TIME_FOREVER</span><br><span class="line">**/</span><br></pre></td></tr></table></figure>
<p>​    还可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_notify(dispatch_group_t group,</span><br><span class="line">                           dispatch_group_t queue,</span><br><span class="line">                           dispatch_group_t block);</span><br><span class="line">/**</span><br><span class="line">这里和wait函数不同的是，这里的块在group的任务执行完之后可以指定线程，假如当前线程不应该阻塞，开发者想在任务全部完成后得到通知，那么这种方式就很有必要。</span><br><span class="line">**/</span><br></pre></td></tr></table></figure>
<ul>
<li>通过dispatch group，可以在并发式派发队列里同时执行多个任务，此时GCD会根据系统资源状况来调度这些并发执行的任务。</li>
</ul>
<h4 id="第45条：使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#第45条：使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="第45条：使用dispatch_once来执行只需运行一次的线程安全代码"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h4><ul>
<li>dispatch_once的函数如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_once(dispatch_once_t *token,</span><br><span class="line">                   dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>该函数接受一个<code>dispatch_once_t</code>的特殊参数作为标记，当标记相同的时候，块里的代码只执行一次，保证了不会重复执行。</p>
<ul>
<li>dispatch_once很方便的帮助在objective-c里实现单例模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)sharedInstance &#123;</span><br><span class="line">    static EOCClass *sharedInstance = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return shareInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    dispatch_once很方便的帮助我们编写只需要执行一次的代码，而且不需要考虑加锁的问题，都由GCD在底层处理。并且dispatch_once更高效。</p>
<ul>
<li>注意dispatch_once_t的变量应该声明在global或static的作用域中，这样的话，每次的标记都是相同的。</li>
</ul>
<h4 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用dispatch_get_current_queue</h4><ul>
<li>dispatch_get_current_queue的函数行为常常和开发者的预期不同，并且已经废弃，只应该在调试的时候使用。</li>
<li>派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。</li>
<li>dispatch_get_current_queue函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能该用队列特定数据来解决。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		11490
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/23/effective-Objective-C2-0总结与笔记-第六章/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/17/effective-Objective-C2-0总结与笔记-第五章/">Effective Objective-C 2.0 总结与笔记（第五章）—— 内存管理</a>  
	       
		 

		 <time>2018-11-17 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第五章：内存管理"><a href="#第五章：内存管理" class="headerlink" title="第五章：内存管理"></a>第五章：内存管理</h3><p>​    内存管理是Objective-C里重要的概念，要写出内存使用效率高又没有bug的代码，就需要掌握其内存管理的种种细节。Objective-C的内存管理因为有自动引用计数，所以并不复杂，ARC几乎把所有的内存管理的事情都交给编译器决定，作为开发者只需要专注于业务逻辑。</p>
<h4 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h4><ul>
<li>Objective-C对象使用引用计数来管理内存，每个对象都有一个可以递增或者递减的计数器，如果想使对象继续存活就要递增其引用计数，用完了之后就需要递减。</li>
<li>在ARC中，所有与引用计数有关的方法的无法编译。虽然不能直接调用，但是理解这些方法能够帮助我们去理解引用计数的概念，ARC也是一种引用计数机制。</li>
<li>引用计数的原理：NSObject协议生命了3个方法用于操作计数器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retain: 递增保留计数</span><br><span class="line">release: 递减保留计数</span><br><span class="line">autorealease: 待稍后清理&quot;自动释放池&quot;时，再递减保留计数</span><br></pre></td></tr></table></figure>
<ul>
<li>保留计数至少为1，当对象被初始化之后，对象的引用计数为1，然后如果被强引用，那么表示其他对象想令其继续存活，就可以保留（引用计数+1），等到用完之后，再释放（引用计数-1），当引用计数降至0的时候，那么对象所占的内存也许被回收，一般为了保证不会出现可能指向无效对象的指针（悬挂指针），可以在realease之后清空指针。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line">number = nil;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性存取方法的内存管理：如果属性为<code>strong</code>的修饰符修饰，那么设置的属性值会保留：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFoo:(id)foo &#123;</span><br><span class="line">    [foo retain];//保留新值</span><br><span class="line">    [_foo release];//释放旧值</span><br><span class="line">    _foo = foo;//让实例变量指向新值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动释放池：调用autorelease会在稍后递减引用计数，通常是下一次事件循环（event loop），也有可能更早。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">使用以下的方法会让引用计数+1，而没有释放操作</span><br><span class="line">*/</span><br><span class="line">- (NSString *)stringValue &#123;</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;Test String Value&quot;];</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">使用autorelease能够很好的避免这种情况，给调用者留下足够的时间。</span><br><span class="line">*/</span><br><span class="line">- (NSString *)stringValue &#123;</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;Test String Value&quot;];</span><br><span class="line">    return [str autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>保留环，如果几个对象相互引用，这样会导致内存泄漏，因为循环中的对象其引用计数不会降为0。通常的解决方案是使用弱引用代替强引用。</li>
</ul>
<h4 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h4><ul>
<li>ARC就是自动引用计数，引用计数实际上还是要执行的，只不过保留和释放操作都是由ARC自动为你添加，所以不能直接在ARC下调用内存管理相关的方法：<code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>dealloc</code>。而且ARC调用的并不是Objective-C的这些方法，而是和这些方法等效的C语言版本，这样可以节省更多的CPU周期。</li>
<li>使用ARC必须遵循的方法命名规则：如果使用以下词语开头的方法，其返回对象归调用者所有：<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>。归调用者所有的意思是：调用上述四种方法的那段代码要负责释放所返回的对象。</li>
<li>若方法名不以上述四个词语开头，则表示其返回的对象并不归调用者所有，这种情况下所返回的对象会自动释放。</li>
<li>ARC具有向后兼容的特性，他可以兼容那些不使用ARC的代码。ARC有特殊的函数能优化函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (EOCPerson *)personWithName:(NSString *)name &#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] init];</span><br><span class="line">    person.name = name;</span><br><span class="line">    objc_autoreleaseReturnValue(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//code using EOCPerson Class</span><br><span class="line">EOCPerson *tmp = [EOCPerson personWithName:@&quot;GDGD&quot;];</span><br><span class="line">_myperson = objc_retainAutoreleasedReturnValue(tmp);</span><br><span class="line"></span><br><span class="line">id objc_autoreleaseReturnValue(id object) &#123;</span><br><span class="line">    if (/* caller will retain object */) &#123;</span><br><span class="line">        set_flag(object);//设置标志位，表示对象要执行retain操作</span><br><span class="line">        return object; // No autorelease;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return [object autorelease];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id objc_retainautoreleasedReturnValue(id object) &#123;</span><br><span class="line">    if (get_flag(object)) &#123;</span><br><span class="line">        clear_flag(object);</span><br><span class="line">        return object;//No retain;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return [object retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    将内存管理交给编译器和运行期组件来做，代码可以得到多种优化，上面只是其中一种。</p>
<ul>
<li>变量的内存管理语义：ARC会用一种安全的方式来设置，先保留新值，在释放旧值，最后设置实例变量。而且使用了ARC之后无需考虑这些情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__strong：默认语义，保留此值;</span><br><span class="line">__unsafe_unretained：不保留此值，这样可能不安全，等到再次使用变量的时候，对象可能已经被回收了;</span><br><span class="line">__weak：不保留此值，但是变量可以安全使用，如果对象被回收，那变量也会自动清空;</span><br><span class="line">__autoreleasing：把对象按引用传递给方法的时候，使用这个特殊的修饰符，在返回时自动释放;</span><br></pre></td></tr></table></figure>
<p>​    使用<code>__weak</code>和<code>__unsafe_unretained</code>可以打破保留环。</p>
<ul>
<li>在手动引用计数的时候，可以这样编写<code>dealloc</code>方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_foo release];</span><br><span class="line">    [_bar release];</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在ARC里不能直接调用<code>dealloc</code>，但是非Objective-C对象还是需要清理，可以这样写<code>dealloc</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    CFRelease(_coreFoundationObject);</span><br><span class="line">    free(_heapAllocatedMemoryBlob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不使用ARC，可以覆写内存管理方法。例如将单例模式下的<code>release</code>方法替换为空操作。</li>
</ul>
<h4 id="第31条：在dealloc方法中只释放引用并解除监听"><a href="#第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="第31条：在dealloc方法中只释放引用并解除监听"></a>第31条：在dealloc方法中只释放引用并解除监听</h4><ul>
<li>对象在声明周期结束后，会被系统回收，就需要执行<code>dealloc</code>方法了，这个方法在对象的引用计数降为0的时候被执行。</li>
<li><code>dealloc</code>主要做以下几个事情：<ul>
<li>释放所有的Objective-C对象，ARC会通过自动生成的.cxx_destruct方法在<code>dealloc</code>中自动添加这些释放方法。</li>
<li>手动释放非Objective-C对象。</li>
<li>将配置过的观测行为都清理掉，如果把通知发给了释放的对象，那么会令应用程序崩溃。</li>
</ul>
</li>
<li>在iOS系统里，应用程序终止时则会调用<code>UIApplicationDelegate</code>中的下述方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br></pre></td></tr></table></figure>
<ul>
<li>尽量不要在<code>dealloc</code>里调用其他方法。执行异步任务的方法不应该在<code>dealloc</code>里调用，只能在正常状态下执行的方法也不应在<code>dealloc</code>里调用，因为此时对象已经处于正在回收的状态了。</li>
</ul>
<h4 id="第32条：编写“异常安全代码”时留意内存管理问题"><a href="#第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第32条：编写“异常安全代码”时留意内存管理问题"></a>第32条：编写“异常安全代码”时留意内存管理问题</h4><ul>
<li>在Objective-C的错误模型里，异常应该在发生严重错误后抛出。</li>
<li>如果使用手动引用计数，就需要手动处理异常的时候的内存管理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">    EOCSomeClass *object = [[EOCSomeClass alloc] init];</span><br><span class="line">    [object doSomething];</span><br><span class="line">    //如果把释放放在这里的话，那么可能在doSomething发生异常，导致内存泄漏</span><br><span class="line">&#125;</span><br><span class="line">@catch(...) &#123;</span><br><span class="line">    NSLog(@&quot;...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@finally &#123;</span><br><span class="line">    [object release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在ARC里，由于不能手动管理内存，所以如果异常出现对象并不会被释放，这样可能出现异常泄漏，虽然也可以开启手动内存管理，但是默认不开启的原因是因为：在Objective-C中，只有引用程序因异常状况而终止时才应该抛出异常，如果应用程序终止了，是否发生内存泄漏就已经无关紧要了。所以如果去处理反而会影响运行效率。</li>
</ul>
<h4 id="第33条：以弱引用避免保留环"><a href="#第33条：以弱引用避免保留环" class="headerlink" title="第33条：以弱引用避免保留环"></a>第33条：以弱引用避免保留环</h4><ul>
<li>如果对象之间以某种方式互相引用，从而形成环，因为Objective-C采用引用计数的内存管理机制，这样就会导致内存泄漏。</li>
<li>一个最简单的保留环：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@class EOCClassA;</span><br><span class="line">@class EOCClassB;</span><br><span class="line"></span><br><span class="line">@interface EOCClassA : NSObject</span><br><span class="line">@property (nonatomic, strong) EOCClassB *other;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCClassB : NSObject</span><br><span class="line">@property (nonatomic, strong) EOCClassA *other;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>​    避免保留环最佳方式就是弱引用，这种引用表示非拥有关系，不会让引用计数+1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, unsafe_unretained) EOCClassA *other;</span><br><span class="line">//或者</span><br><span class="line">@property (nonatomic, weak) EOCClassA *other;</span><br></pre></td></tr></table></figure>
<p>属性特质的<code>unsafe_unretained</code>表明属性可能不安全，如果系统已经把属性所指的对象回收了，那么在其上调用方法可能会导致应用程序崩溃，因为本对象不保留属性对象，因此有可能为系统所回收。</p>
<p>使用<code>weak</code>的话，就可以避免这种情况，它的作用和<code>unsafe_unretained</code>相同，但是在属性被系统回收后，属性值会自动设置为nil。</p>
<p>也就是说：当只想<code>EOCClassA</code>实例的引用移除后，<code>unsafe_unretained</code>属性仍然指向被回收的那个实例，但是<code>weak</code>指向nil。</p>
<h4 id="第34条：以“自动释放池块”降低内存峰值"><a href="#第34条：以“自动释放池块”降低内存峰值" class="headerlink" title="第34条：以“自动释放池块”降低内存峰值"></a>第34条：以“自动释放池块”降低内存峰值</h4><ul>
<li><p>释放对象有两种方式：</p>
<ul>
<li>调用release方法，使其引用计数立即递减。</li>
<li>调用autorelease方法，将其加入“自动释放池”中。清空自动释放池的时候，系统会向其中的对象发送release消息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//自动释放池的方法：</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说不需要自己创建自动释放池，通常只需要在main函数里使用自动释放池来包裹应用程序的主入口点。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这个池可以理解为最外围捕捉全部自动释放对象所用的池。</p>
<ul>
<li><p>自动释放池可以嵌套，它于左花括号处创建，并对应右花括号处自动清空，位于自动释放池内的对象，在范围的末尾处收到release消息。自动释放池嵌套使用的好处是可以控制应用程序的内存峰值，使其不至过高。</p>
<p>如果要从数据库里读取数据，那么可能在读取的时候会有新对象创建并加入自动释放池，这样所有对象要等到for循环执行完才会释放，导致内存过高。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//通过下面的方式，加入EOCPerson在创建的时候同时还有很多临时对象的创建，那么内存中会有很多不必要的临时对象没有被释放，导致内存过高</span><br><span class="line">NSArray *databaseRecords = /* record from database */;</span><br><span class="line">NSMutableArray *people = [NSMutableArray new];</span><br><span class="line">for (NSDictionary *record in databaseRecords) &#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">    [people addObject:person];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//要解决这个问题，增加一个自动释放池就可以</span><br><span class="line">NSArray *databaseRecords = /* record from database */;</span><br><span class="line">NSMutableArray *people = [NSMutableArray new];</span><br><span class="line">for (NSDictionary *record in databaseRecords) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">    	[people addObject:person];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//这样循环中自动释放的对象就会放在这个池子，而不是线程的主池里</span><br></pre></td></tr></table></figure>
<ul>
<li>自动释放池的也有开销，尽量不要建立额外的自动释放池。<code>@autoreleasepool</code>的方式能够更方便的创建出自动释放池。</li>
</ul>
<h4 id="第35条：用”僵尸对象“调试内存管理问题"><a href="#第35条：用”僵尸对象“调试内存管理问题" class="headerlink" title="第35条：用”僵尸对象“调试内存管理问题"></a>第35条：用”僵尸对象“调试内存管理问题</h4><ul>
<li><p>主要是使用instrument来进行调试，这里不做详述，贴一个我觉得写的不错的博客吧。</p>
<p><a href="https://www.jianshu.com/p/f6e6b4f21ca2" target="_blank" rel="noopener">iOS 僵尸对象调试</a></p>
</li>
</ul>
<h4 id="第36条：不要使用retainCount"><a href="#第36条：不要使用retainCount" class="headerlink" title="第36条：不要使用retainCount"></a>第36条：不要使用retainCount</h4><ul>
<li>NSObject协议里定义了一个方法，可以查询当前的引用计数，这个方法在ARC中是不可用的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount</span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法是无用的，因为所返回的引用计数只是某个时间点上的值，并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去。</li>
<li>同时这个方法可能永远不返回0，因为可能在保留计数还是1的时候，就被系统回收了。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		6160
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/17/effective-Objective-C2-0总结与笔记-第五章/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/15/effective-Objective-C2-0总结与笔记-第四章/">Effective Objective-C 2.0 总结与笔记（第四章）—— 协议与分类</a>  
	       
		 

		 <time>2018-11-15 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第四章：协议与分类"><a href="#第四章：协议与分类" class="headerlink" title="第四章：协议与分类"></a>第四章：协议与分类</h3><p>​    Objective-C语言有一项特性叫做“协议”，类似与Java的“接口”。Objective-C不支持多重继承，所以我们把某个类应该实现的一系列方法定义在协议里面。最为常见的用途就是实现委托模式了。</p>
<p>​    “分类”也是Objective-C的一项重要特性，利用分类机制，无须继承子类即可直接为当前类添加方法。</p>
<h4 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h4><ul>
<li>委托模式的编程设计模式来实现对象间的通信，该模式的主旨是：<ul>
<li>定义一套接口。</li>
<li>如果对象想接受另一个对象的委托，那么就要遵循这个接口，以便其称为其“委托对象”。</li>
</ul>
</li>
</ul>
<p>example：<code>EOCDataModel</code>请求<code>EOCNetworkFetcher</code>以异步的方式执行一项任务，而<code>EOCNetworkFetcher</code>执行完这项任务之后，就会通知其委托对象，也就是<code>EOCDataModel</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//EOCNetworkFetcher.h</span><br><span class="line">@class EOCNetworkFetcher;</span><br><span class="line">//定义一个协议</span><br><span class="line">@protocol EOCNetworkFetcherDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">-(void)networkFetcher:(EOCNetworkFetcher *)fetcher didReceiveData:(NSData *)data;</span><br><span class="line">-(void)networkFetcher:(EOCNetworkFetcher *)fetcher didFailWithError:(NSError *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//有了协议之后就可以使用一个属性来存放其委托对象了。这个属性需要使用weak，而不是strong，因为DataModel和NetworkFetcher必须为非拥有关系，通常情况下，扮演delegate的对象也要持有本对象。使用weak能防止保留环的产生。    </span><br><span class="line">@interface EOCNetworkFetcher : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic , weak) id&lt;EOCNetworkFetcherDelegate&gt; delegate;//利用属相来存放委托对象</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//EOCNetworkFetcher.m</span><br><span class="line">#import &quot;EOCNetworkFetcher.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation EOCNetworkFetcher</span><br><span class="line">-(void)didSomeSthing&#123;</span><br><span class="line"></span><br><span class="line">    if ([_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)])&#123;</span><br><span class="line">        [_delegate networkFetcher:nil didReceiveData:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//EOCDataModel 实现EOCNetworkFetcherDelegate</span><br><span class="line">//EOCDataModel.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;EOCNetworkFetcher.h&quot;</span><br><span class="line">@interface EOCDataModel : NSObject&lt;EOCNetworkFetcherDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//EOCDataModel.m</span><br><span class="line">#import &quot;EOCDataModel.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation EOCDataModel</span><br><span class="line">-(void)networkFetcher:(EOCNetworkFetcher *)fetcher didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">//do some things</span><br><span class="line">&#125;</span><br><span class="line">-(void)networkFetcher:(EOCNetworkFetcher *)fetcher didFailWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>委托协议一般使用<code>@optional</code>关键字来表示可选的，一般情况下都说使用这个方式来实现。</p>
</li>
<li><p>也可以使用协议定义一套接口，令某类经由该接口获取其所需的数据。委托模式的这一用法又称数据源模式，因为信息从数据源流向类。</p>
</li>
<li>若有必要，可以使用含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li>
</ul>
<h4 id="第24条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第24条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第24条：将类的实现代码分散到便于管理的数个分类之中"></a>第24条：将类的实现代码分散到便于管理的数个分类之中</h4><ul>
<li>如果一个类的代码全部放在一个巨大的实现文件里，可能可阅读性会差一点，那么可以通过Objective-C的分类机制，把类代码按逻辑划入几个分区中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFirstName:(NSString *)firstName</span><br><span class="line">                      andlastName:(NSString *)lastName;</span><br><span class="line"></span><br><span class="line">//friend method</span><br><span class="line">- (void)addFriend:(EOCPerson *)person;</span><br><span class="line">- (void)removeFriend:(EOCPerson *)person;</span><br><span class="line">- (void)isFriendWith:(EOCPerson *)person;</span><br><span class="line"></span><br><span class="line">//work method</span><br><span class="line">- (void)performDaysWork;</span><br><span class="line">- (void)takevacationFromWork;</span><br><span class="line"></span><br><span class="line">//play method</span><br><span class="line">- (void)goToTheCinema;</span><br><span class="line">- (void)goToSportGame;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//如果利用分类的方式，可以拆成3个分类</span><br><span class="line">@interface EOCPerson (Friendship)</span><br><span class="line">- (void)addFriend:(EOCPerson *)person;</span><br><span class="line">- (void)removeFriend:(EOCPerson *)person;</span><br><span class="line">- (void)isFriendWith:(EOCPerson *)person;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">@interface EOCPerson (Work)</span><br><span class="line">- (void)performDaysWork;</span><br><span class="line">- (void)takevacationFromWork;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">@interface EOCPerson (Play)</span><br><span class="line">- (void)goToTheCinema;</span><br><span class="line">- (void)goToSportGame;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>如果编写准备分享给其他开发者使用的程序库的时候，可以创建Private分类，把私有方法归入到Private分类中。</li>
</ul>
<h4 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h4><ul>
<li>向第三方类中加分类的时候，应该添加上前缀，而对应的方法名也应该加上前缀。这样做的目的是防止因为没有加前缀而导致重复的分类被创建，或者分类下的方法命名重复，因为Objective-C没有命名空间，所以可能会出现意想不到的问题。</li>
</ul>
<h4 id="第26条：勿在分类中声明属性"><a href="#第26条：勿在分类中声明属性" class="headerlink" title="第26条：勿在分类中声明属性"></a>第26条：勿在分类中声明属性</h4><ul>
<li>除了”class-continuation分类“（拓展），其他分类都无法向类中新增实例变量。他们无法把实现属性所需的实例变量合成出来，如果使用关联对象可以解决分类不能合成实例变量的问题，但是这样代码冗余度会提高，同时可能出现内存管理的问题。</li>
<li>尽量把全部属性都定义在主接口里，而在”class-continuation分类“以外的分类，可以定义存取方法，但是尽量不要声明属性。</li>
</ul>
<h4 id="第27条：使用”class-continuation分类“隐藏实现细节"><a href="#第27条：使用”class-continuation分类“隐藏实现细节" class="headerlink" title="第27条：使用”class-continuation分类“隐藏实现细节"></a>第27条：使用”class-continuation分类“隐藏实现细节</h4><ul>
<li>Objective-C动态消息系统的工作方式决定了不可能实现真正的私有方法或私有实例变量。如果确实是不需要对外公布确应该具有的方法和实例变量应该使用”class-continuation分类“来实现。</li>
<li>“class-continuation分类“和普通的分类不同，他必须定义在所拓展的那个类的实现文件里，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//EOCPerson.m</span><br><span class="line">@interface EOCPerson () &#123;</span><br><span class="line">    //实例变量</span><br><span class="line">&#125;</span><br><span class="line">//方法和属性</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>实例变量也可以声明到实现块里，语法上和”class-continuation分类“里定义一样。</p>
<ul>
<li>编写Objective-C++代码的时候，使用”class-continuation分类“也更为有效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//EOCClass.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#include &quot;SomeCppClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface EOCClass : NSObject &#123;</span><br><span class="line">@private</span><br><span class="line">    SomeCppClass _cppDemo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>假如一个类的头文件声明如上，那么其实现文件应该是<code>EOCClass.mm</code>，表示告诉编译器应该将此文件使用Objective-C++的方式进行编译，但是由于头文件里包含了CPP文件，那么如果其他引入该头文件的类，都需要使用<code>.mm</code>的拓展名，这样并不是非常合适。</p>
<p>最好的解决方案就是使用”class-continuation分类“。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//EOCClass.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCClass : NSObject </span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//EOCClass.m</span><br><span class="line">#import &quot;EOCClass.h&quot;</span><br><span class="line">#include &quot;SomeCppClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface EOCClass () &#123;</span><br><span class="line">    SomeCppClass _cppDemo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCClass</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样其头文件就不会出现CPP文件了，使用头文件的人也不会意识到这个底层的实现使用了CPP的代码，很好的隐藏了实现细节。</p>
<ul>
<li>“class-continuation分类“还有一种用法就是将在public接口中声明为“只读”的属性扩展为“可读写”，以便在类内部设置其值。因为这样可以不用直接访问实例变量，而是通过设置访问方法来做，就可以触发KVO通知。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFirstName:(NSString *)firstName</span><br><span class="line">                      andlastName:(NSString *)lastName;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">@interface EOCPerson ()</span><br><span class="line">    </span><br><span class="line">@property(nonatomic, copy, readwrite) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy, readwrite) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>“class-continuation分类“还可以定义私有的协议。有时由于对象所遵从的某个协议在某个私有API中，所以可能不太想在公共接口中泄露这一信息。</li>
</ul>
<h4 id="第28条：通过协议提供匿名对象"><a href="#第28条：通过协议提供匿名对象" class="headerlink" title="第28条：通过协议提供匿名对象"></a>第28条：通过协议提供匿名对象</h4><ul>
<li>协议定义了一系列方法，遵从此协议的对象应该实现它们，于是可以用协议把自己所写的API之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯id类型，这样想要隐藏的类名就不会出现在API之中了。这一概念常常被称为“匿名对象”。在委托里，经常定义匿名对象，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;EOCDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>该属性是<code>id&lt;EOCDelegate</code>的，实际上任何类的对象都能充当这一属性，只需要遵循<code>EOCDelegate</code>即可。</p>
<ul>
<li><code>NSDictionary</code>也有应用这一概念，在可变版本的字典里，设置键值对所用的方法的签名是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key;</span><br></pre></td></tr></table></figure>
<p>表示键值对的参数都可以是任意类型，key参数可以视为匿名对象，字典不关心key对象的所属的具体类，字典对象只需要确定能给此实例发送拷贝消息就可以。</p>
<ul>
<li><p>匿名对象的作用主要是：</p>
<ul>
<li><p>隐藏类型名称。</p>
</li>
<li><p>对于不关心具体类型，只是关心是否能响应特定方法的情况，可以使用匿名对象。</p>
</li>
</ul>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		5390
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/15/effective-Objective-C2-0总结与笔记-第四章/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/13/effective-Objective-C2-0总结与笔记-第三章/">Effective Objective-C 2.0 总结与笔记（第三章）—— 接口与API设计</a>  
	       
		 

		 <time>2018-11-13 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第三章：接口与API设计"><a href="#第三章：接口与API设计" class="headerlink" title="第三章：接口与API设计"></a>第三章：接口与API设计</h3><p>​    在开发应用程序的时候，总是不可避免的会用到他人的代码，或者自己的代码被他人所利用，所以要把代码写的更清晰一点，方便其他开发者能够迅速而方便地将其集成到他们的项目里。</p>
<h4 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h4><ul>
<li><p>Objective-C没有内置的命名空间机制（namespace），所以命名的时候需要设法避免潜在的命名冲突，否则就很容易重名了。如果发生命名冲突，那么应用程序的链接过程就会出错。比无法链接更糟糕的是在运行期载入了含有重名类的程序库，这时候就会有”重名符号错误”，很可能导致整个程序崩溃。</p>
</li>
<li><p>为了避免这种问题，我们可以变相实现命名空间：为所有的名称加上这个程序相关的前缀。需要注意的是，Apple宣称保留使用所有“两字母前缀“的权利，所以自己选用的前缀应该是3个字母。</p>
</li>
<li><p>如果在第三方库的基础上进行了开发后再次封包，则需要将所有的文件前缀修改成和第三方库之前匹配的前缀，才可以封包给其他人使用。</p>
<p>example：EOCLibrary里扩展了XYZLibrary的东西，那么就要把XYZLibrary的相关前缀改成EOC的前缀。</p>
</li>
</ul>
<h4 id="第16条：提供“全能初始化方法”"><a href="#第16条：提供“全能初始化方法”" class="headerlink" title="第16条：提供“全能初始化方法”"></a>第16条：提供“全能初始化方法”</h4><ul>
<li>所有对象均要初始化，可为对象提供必要信息以便其能完成工作的初始化方法叫做全能初始化方法。如果创建类实例的方法不止一种，那么这个类就会有多个初始化方法，这里需要选定一个初始化方法作为全能初始化方法，令其他初始化方法都调用它。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</span><br></pre></td></tr></table></figure>
<p>在上面的代码里，<code>initWithTimeIntervalSinceNow</code>就是全能初始化方法，其他所有的初始化方法都要调用它，所以只有该方法才会存储内部数据，当内部数据改变的时候，仅需要改变全能初始化方法即可。</p>
<ul>
<li>如果子类的全能初始化方法与超类的不同，那么应该覆写超类的全能初始化方法。</li>
<li>在Objecive-C程序中，只有发生严重错误的时候才应该抛出异常，初始化的时候抛出异常是不得已之举，表明实例真的没办法初始化了。</li>
</ul>
<h4 id="第17条：实现description方法"><a href="#第17条：实现description方法" class="headerlink" title="第17条：实现description方法"></a>第17条：实现description方法</h4><ul>
<li><p>调试程序的时候，经常需要打印并查看对象信息，一般有两种方法：</p>
<ul>
<li>编写代码把对象的全部属性输出到日志中。</li>
<li>直接打印对象，通过实现description方法，将信息打印出来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//EOCPerson.h</span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//EOCPerson.m</span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p,\&quot;%@ %@\&quot;&gt;&quot;,</span><br><span class="line">            [self class], self, _firstName, _lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//test</span><br><span class="line">EOCPerson *person = [EOCPerson new];</span><br><span class="line">person.firstName = @&quot;Bob&quot;;</span><br><span class="line">person.lastName = @&quot;Smith&quot;;</span><br><span class="line">NSLog(@&quot;person = %@&quot;, person);</span><br><span class="line">/**</span><br><span class="line">person = &lt;EOCPerson: 0x7bf240c030f0,&quot;Bob Smith&quot;&gt;</span><br><span class="line">**/</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要输出很多互不相同的信息，可以借助<code>NSDictionary</code>：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p,%@&gt;&quot;,</span><br><span class="line">            [self class],</span><br><span class="line">            self,</span><br><span class="line">            @&#123;@&quot;firstName&quot;:_firstName,</span><br><span class="line">              @&quot;lastName&quot;:_lastName&#125;</span><br><span class="line">            ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想在LLDB里通过<code>po</code>指令输出，那么就应该实现<code>debugDescription</code>方法，和<code>Description</code>方法一样。</li>
</ul>
<h4 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h4><ul>
<li>在实际编程中，应该尽量把对外公布的属性设为只读，而且只在确有必要的时候才将属性对外公布。</li>
<li>如果使用了<code>readonly</code>属性，那么有人试着改变属性值，编译器就会报错。这样只能在对象内部进行修改。</li>
<li>有时可能想修改封装在对象外部的属性，却不想令这些数据为外人所动，这种情况下可以利用”class-continuation分类”，将<code>readonly</code>改为<code>readwrite</code>。其实是等于在内部使用Extension的方式来实现。在对象外部，也可以通过KVC的方式来设置这些属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//EOCPointInterest.h</span><br><span class="line">@interface EOCPointInterest : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identifier;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//EOCPointInterest.m</span><br><span class="line">#import &quot;EOCPointInterest.h&quot;</span><br><span class="line">@interface EOCPointInterest()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readwrite) NSString *identifier;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCPointInterest</span><br><span class="line">...</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//outter</span><br><span class="line">[pointOfInterest setValue:@&quot;GDGD&quot; forKey:@&quot;identifier&quot;];</span><br></pre></td></tr></table></figure>
<p>这样可以直接改动<code>identifier</code>属性，即使没有于公共接口中公布这个方法，它依然可以违规的绕过本类的API。</p>
<ul>
<li>定义一些公共API的时候，可能会涉及到collection，这些属性应该设置成可变还是不可变是需要好好考虑清楚的。如果是可变的collection的话，不要把可变的collection作为属性公开，而应该提供相关方法让别人通过方法去修改collection。</li>
</ul>
<h4 id="第19条：使用清晰而协调的命名方式"><a href="#第19条：使用清晰而协调的命名方式" class="headerlink" title="第19条：使用清晰而协调的命名方式"></a>第19条：使用清晰而协调的命名方式</h4><ul>
<li>这一章暂且略过，毕竟命名还是一个比较复杂的部分，而且每个工程都有自己的一套特色。这里只简单说一下大原则。</li>
<li>在Objective-C里，命名要求尽量清晰，不使用缩略，让代码读起来像句子一样。</li>
<li>类和协议的命名应该加上前缀，避免命名空间冲突。</li>
</ul>
<h4 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h4><ul>
<li>一般来说私有方法是指在内部使用不暴露在外面的方法，这种方法可以通过加前缀的方式方便调试，同时也可以通过前缀来查找以方便统一修改私有代码。</li>
<li>不要单用一个下划线作为私有方法的前缀，这是预留给苹果公司用的。</li>
</ul>
<h4 id="第21条：理解Objective-C错误模型"><a href="#第21条：理解Objective-C错误模型" class="headerlink" title="第21条：理解Objective-C错误模型"></a>第21条：理解Objective-C错误模型</h4><ul>
<li>在Objective-C里，自动引用计数默认情况下不是异常安全的，也就是如果抛出异常那么该对象就不会自动释放了。如果要异常安全的话需要做一些额外操作。</li>
<li>即使使用ARC，也可能导致内存泄露：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id someResource = [someClass new];</span><br><span class="line">if (/* check for error */) &#123;</span><br><span class="line">    @throw [NSEXception exceptionWithName:@&quot;Exception&quot;</span><br><span class="line">            reason:@&quot;ther is a error&quot;</span><br><span class="line">            userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line">[someResource doSomething];</span><br><span class="line">[someResource release];</span><br></pre></td></tr></table></figure>
<p>如果上述代码发生了异常之后，那么资源就不可能被释放掉了。如果要正确释放应该在抛出异常之前释放掉资源。</p>
<ul>
<li><p>现在Objective-C采用的方法是尽量不抛出异常，如果抛出异常了无需考虑恢复问题，应用程序也应该退出。</p>
</li>
<li><p>如果不是那么严重的异常，一般可以令方法返回<code>nil/0</code>，或者是使用<code>NSError</code>，表明有错误发生。</p>
</li>
<li><p><code>NSError</code>的用法更加灵活，并且这个模型可以添加描述错误的原因。</p>
<ul>
<li>Error domain (错误范围，类型为字符串)：错误发生的根源，通常用一个特有的全局变量来定义。</li>
<li>Error code (错误码，类型为整数)：独有的错误代码，用来指明在某个范围内具体发生了何种错误。</li>
<li>User info (用户信息，类型为字典)：关于错误的额外信息。</li>
</ul>
<p><code>NSError</code>的常见用法主要有两种：</p>
<ul>
<li>通过委托协议来传递此错误，有错误发生时，当前对象会把错误信息经由协议中的某个方法给其委托对象。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br></pre></td></tr></table></figure>
<ul>
<li>经由输出参数返回给调用者，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)doSomething:(NSError **)error;</span><br><span class="line"></span><br><span class="line">//example</span><br><span class="line">NSError *error = nil;</span><br><span class="line">BOOL ret = [object doSomething:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    //handle the error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    实际上使用ARC的时候，编译器会把方法签名中的<code>NSError **</code>转换成<code>NSError * __autoreleasing*</code>，也就是指针所指的对象在方法执行完毕后自动释放。</p>
<p>​    定义错误码的时候最好使用枚举的方式实现，并且最好在定义这些枚举的头文件里对每个错误类型详细说明。</p>
</li>
</ul>
<h4 id="第22条：理解NSCopying协议"><a href="#第22条：理解NSCopying协议" class="headerlink" title="第22条：理解NSCopying协议"></a>第22条：理解NSCopying协议</h4><ul>
<li>如果想要自己的类支持copy方法，那就要实现<code>NSCopying</code>协议，该协议只有一个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure>
<p><code>NSZone</code>是以前开发程序时，会把内存分成不同的区，而对象会创建在不同的区，现在每个程序只有一个默认区，尽管必须实现这个方法，但是<code>zone</code>参数不用担心。copy方法是由<code>NSObject</code>实现，该方法只是以默认区为参数来调用。</p>
<p>example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//EOCPerson.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//实现NSCopying的方法</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    EOCPerson *copy = [[self class] allocWithZone:zone];</span><br><span class="line">    copy.firstName = _firstName;</span><br><span class="line">    copy.lastName = _lastName;</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果要访问类的内部实例变量（并非属性），那么需要用<code>-&gt;</code>的语法来访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@implementation EOCPerson &#123;</span><br><span class="line">    NSMutableSet *_friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果要访问，那么就是</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    /* copy something*/</span><br><span class="line">    copy-&gt;_friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了copy方法以外，还有mutableCopy方法，这个是来自于<code>NSMutableCopying</code>的协议，如果要实现一个可变的拷贝，那么就需要实现该协议的方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure>
<p>对于不可变的NSArray与可变的NSMutableArray来说，下列关系成立:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NSArray copy] =&gt; NSArray;</span><br><span class="line">[NSArray mutableCopy] =&gt; NSMutableArray;</span><br><span class="line"></span><br><span class="line">[NSMutableArray copy] =&gt; NSArray;</span><br><span class="line">[NSMutableArray mutableCopy] =&gt; NSMutableArray;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在编写拷贝方法的时候，还需要注意一个问题那就是拷贝执行的是深拷贝还是浅拷贝。</p>
<ul>
<li>深拷贝：拷贝对象的时候底层数据也一并复制过去。</li>
<li>浅拷贝：只拷贝容器本身，而不复制其中数据。<code>Foundation</code>框架的所有<code>collection</code>类在默认情况下都执行浅拷贝，因为<code>collection</code>里可能存在无法拷贝的数据，或者并非需要深拷贝。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)deepCopy &#123;</span><br><span class="line">    EOCPerson *copy = [[[self class] alloc] init];</span><br><span class="line">    copy.firstName = _firstName;</span><br><span class="line">    copy.lastName = _lastName;</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		5880
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/13/effective-Objective-C2-0总结与笔记-第三章/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/">Effective Objective-C 2.0 总结与笔记（第二章）—— 对象、消息、运行期</a>  
	       
		 

		 <time>2018-11-10 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第二章：对象、消息、运行期"><a href="#第二章：对象、消息、运行期" class="headerlink" title="第二章：对象、消息、运行期"></a>第二章：对象、消息、运行期</h3><p>​    “对象”就是“基本构造单元”，开发者可以通过对象来存储并传递数据。对象之间传递数据并执行任务的过程就是“消息传递”。程序运行起来后，为其提供相关支持的代码就是“Objective-C运行期环境”，它提供了一些使得对象之间能够传递消息的重要函数，并且包括创建类实例所用的全部逻辑。</p>
<h4 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h4><ul>
<li>”属性“ (property) 是Objective-C的一项特性，用于封装对象中的数据。实例变量一般通过“存取方法”来访问，其中getter用于读取变量值，setter用于写入变量值。开发者可以令编译器自动编写与属性有关的存取方法。</li>
<li>Objective-C语言很少将实例变量放在类接口的public区段内，更多的是使用<code>@property</code>的方式来声明。这是因为如果直接使用public的区段，当实例变量的偏移量改变（原有的实例变量里插入了新的实例变量）的时候，需要重新编译，假如代码库中某份代码使用了旧的类定义，就会出现不兼容的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//public区段内声明实例变量</span><br><span class="line">@interface EOCPerson : NSObject &#123;</span><br><span class="line">@public</span><br><span class="line">    NSData *_dataOfBirth;</span><br><span class="line">    NSString *_firstName;</span><br><span class="line">    NSString *_lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用@property方式声明</span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *firstName;</span><br><span class="line">@property(nonatomic, copy) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//@property方式等效于</span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (NSString *)firstName;</span><br><span class="line">- (void)setFirstName;</span><br><span class="line">- (NSString *)lastName;</span><br><span class="line">- (void)setLastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果要访问属性，可以使用“点语法”，编译器会把“点语法”转换成对存取方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EOCPerson *aPerson = [EOCPerson new];</span><br><span class="line">aPerson.firstName = @&quot;GDGD&quot;;//same as</span><br><span class="line">[aPerson setFirstName:@&quot;GDGD&quot;];</span><br><span class="line"></span><br><span class="line">NSString *lastNameOfGD = aPerson.lastName;//same as</span><br><span class="line">NSString *lastNameOfGD = [aPerson lastName];</span><br></pre></td></tr></table></figure>
<p>使用属性的方式进行声明实例变量，编译器会自动生成存取方法，虽然这个时候在编译器上<strong>看不到</strong>生成的方法，这个方法默认的名字是：getter—就是属性的名字，setter—属性名字前面加set。</p>
<p>如果想要修改“合成方法”的名字，可以使用@synthesize语法来指定关键字的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在实现文件中</span><br><span class="line">@implementation EOCPerson</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果不想要编译器自动生成的方法，可以使用@dynamic语法来阻止编译器的生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation EOCPerson</span><br><span class="line">@dynamic firstName, lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>属性具有四种特质，不同的特质也会影响属性生成的存取方法。</li>
</ul>
<p>(1)、原子性：默认情况下，编译器所合成的方法会通过锁定机制确保其原子性 (atomicity) 。如果属性具备nonatomic特质，则不使用同步锁。<strong>在iOS开发的程序里，由于同步锁开销较大，如果使用原子性的属性会导致性能问题，所以属性都是nonatomic的特质。</strong></p>
<p>(2)、读写权限：</p>
<p>​    readwrite (读写) ：拥有前面说的获取方法 (getter) 和设置方法 (setter)，默认情况。</p>
<p>​    readonly (只读) ：仅拥有获取方法。可以对外暴露为只读属性，然后在“class-continuation分类”中重新定义为读写属性。（27条有说）</p>
<p>(3)、内存管理语义：这是最难理解的部分了，虽然这个特质仅会影响“设置方法”，但是其中涉及到内存管理部分，所以还是非常重要。</p>
<p>​    assign：“设置方法”只会针对“纯量类型”（scalar type，例如CGFloat，NSInteger等）的简单赋值。一般在之前分配在栈里的数据类型就是使用assign修饰。</p>
<p>​    strong：此特质表示一种拥有关系，当给这种属性设置新值的时候，会先保留新值，再释放旧值，然后设置新值上去，一般Objective-C对象使用这个修饰词。</p>
<p>​    weak：表示非拥有关系，为这种属性设置新值的时候，不保留新值，也不释放旧值，当属性所指的对象被销毁的时候，属性值也会被清空。这就是一种弱持有，一般可以用来打破循环引用的情况（后面会介绍）。</p>
<p>​    unsafe_unretained ：语义和assign相同，但是适用于对象类型（object type)，表示一种非拥有关系，但是当目标对象被销毁的时候，属性值不会被清空。</p>
<p>​    copy：和strong类似，但是设置方法并不保留新值，而是将其拷贝。一般NSString <em>就使用这个特质来修饰。这是因为NSString </em>有可能指向一个可变的NSMutableString 实例，如果使用的不是copy的话，那么当可变字符串被篡改后，会影响到你不可变的字符串，所以要拷贝一个不可变的字符串。</p>
<p>(4)、方法名：可以用来指定存取方法的方法名。</p>
<p>​    getter=\&lt;name>：指定获取方法的方法名，如果某属性是Boolean，一般会用这种方式来在获取方法名上加上<code>is</code>前缀。</p>
<p>​    setter=\&lt;name>：指定设置方法的方法名，较少使用。</p>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>在对象之外访问实例变量是通过属性来实现，但是当在对象内部访问实例变量的话最好采用直接访问的形式，而在设置实例变量的时候才通过属性来做。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//使用属性访问</span><br><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFullName &#123;</span><br><span class="line">    NSArray *components = [[self fullName] componentsSeparatedByString:@&quot; &quot;];</span><br><span class="line">    self.firstName = components[0];</span><br><span class="line">    self.lastName = components[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用实例变量访问</span><br><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFullName &#123;</span><br><span class="line">    NSArray *components = [[self fullName] componentsSeparatedByString:@&quot; &quot;];</span><br><span class="line">    _firstName = components[0];</span><br><span class="line">    _lastName = components[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用实例变量和属性访问的区别如下：</p>
<ul>
<li>使用实例变量直接访问由于不经过方法派发，直接访问保存实例变量的那块内存，所以速度更快。</li>
<li>直接访问实例变量可以绕过内存管理语义。</li>
<li>直接访问实例变量不会出发KVO (Key-Value Observing)。</li>
<li>通过属性可以帮助自己debug的时候排查与之相关的错误。</li>
</ul>
<p>知道以上的区别了之后，一般采用一种折中的方案，设置属性使用“设置方法“，读取实例变量则直接访问。</p>
</li>
<li><p>在初始化的时候，如果需要设置实例变量，应当直接访问，因为子类可能会”覆写“设置方法，导致调用到子类的设置方法的时候，出现意想不到的结果。</p>
</li>
<li><p>如果使用了懒加载的方式，就需要使用属性的方式来访问实例变量。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//lazy initialization</span><br><span class="line">- (NSString *)firstName &#123;</span><br><span class="line">    if (!_firstName) &#123;</span><br><span class="line">        _firstName = @&quot;GDGD&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return _firstName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h4><ul>
<li>由于<code>==</code>操作符比较出来的结果未必是我们想要的，因为该操作符是两个指针本身，而不是指针所指的对象。所以一般使用NSObject协议中声明的”isEqual“方法来判断两个对象的等同性。如果是自定义的类，则需要重写该方法以实现等同性判断。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *foo = @&quot;hhh123&quot;;</span><br><span class="line">NSString *bar = [NSString stringWithFormat:@&quot;hhh%i&quot;,123];</span><br><span class="line">Boolean equalA = (foo == bar); // NO</span><br><span class="line">Boolean equalB = [foo isEqual:bar];//YES</span><br><span class="line">Boolean equalC = [foo isEqualToString:bar];//YES</span><br></pre></td></tr></table></figure>
<ul>
<li>NSObject协议中判断对象等同性主要是两个方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object;</span><br><span class="line">- (NSUInteger)hash;</span><br></pre></td></tr></table></figure>
<p>NSObject对这两个方法的默认实现是：指针值完全相等的时候，两个对象才相等。如果isEqual方法为Yes，那么两个对象的hash值相等，反之<strong>不成立</strong>。理解这个意义是自定义实现<code>isEqual:</code>的关键。</p>
<p>设计hash方法的时候，需要尽量减少对象的碰撞，防止出现运算复杂度过大的情况。</p>
<ul>
<li>特定类所具有的等同性判定方法：由于Objective-C在编译期没有做强类型转换，为了增强代码的鲁棒性，应该保证所传对象的类型正确，且有异常处理逻辑。</li>
<li>等同性判定的执行深度：如果是对数组进行等同性判定，往往需要比较两个数组的对应位置的所有对象，这样叫做“深度等同性判定”，如果可以通过identifier来标示等同性，就能大大节省计算。</li>
<li>容器中可变类的等同性：在容器加入可变类对象的时候，把某个对象放入容器之后，就不应该改变其hash值了。由于容器会根据其hash值放在不同的“箱子数组”里，如果放入箱子之后hash值又改变了，那么证明容器放错了箱子，可能会出现隐患。所以需要保证hash值不是根据对象的可变部分来实现的，或者是在其放入容器后就不再改变hash值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSMutableSet *set = [NSMutableSet new];</span><br><span class="line"></span><br><span class="line">NSMutableArray *arrayA = [@[@1, @2] mutableCopy];</span><br><span class="line">[set addObject:arrayA];</span><br><span class="line">//set = &#123;((1,2))&#125;</span><br><span class="line"></span><br><span class="line">NSMutableArray *arrayB = [@[@1] mutableCopy];</span><br><span class="line">[set addObject:arrayB];</span><br><span class="line">//set = &#123;((1),(1,2))&#125;</span><br><span class="line"></span><br><span class="line">[arrayB addObject:@2];</span><br><span class="line">//set = &#123;((1,2),(1,2))&#125; 打破了set的语义</span><br><span class="line"></span><br><span class="line">NSSet *copySet = [set copy];</span><br><span class="line">//copySet = &#123;((1,2))&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第9条：以”类族模式“隐藏实现细节"><a href="#第9条：以”类族模式“隐藏实现细节" class="headerlink" title="第9条：以”类族模式“隐藏实现细节"></a>第9条：以”类族模式“隐藏实现细节</h4><ul>
<li>类族模式可以把实现细节隐藏在一套简单的公共接口后面。Objective-C的系统框架中普遍使用该模式，用户无需自己创建子类实例，只需要调用基类方法来创建即可。</li>
<li>一般采用工厂模式来创建类族。由于Objective-C这门语言没办法指明某个基类是”抽象“的，所以如果使用了类族模式需要写上相应的注释。</li>
<li>Cocoa里的类族：大部分collection类都是类族，如果要子类化这些类族，需要遵守一些规则：<ul>
<li>子类应到继承自类族中的抽象基类：如果要编写NSArray类族的子类，需要继承自不可变数组的基类或者可变数组的基类。</li>
<li>子类应该定义自己的数据存储方式。</li>
<li>子类应当覆写超类文档中指明需要覆写的方法。</li>
</ul>
</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><ul>
<li><p>有时候类的实例可能是由某种机制所创建的，那么也就是无法创建出自己所写的子类实例，那么也就是如果你需要存放对象到类中，就不能通过创建子类的方式实现了。而Objective-C的“关联对象” (associated object) 可以解决这个问题。</p>
<ul>
<li><p>可以给某个对象关联多个对象，通过“键”来区分，同时在创建关联对象的时候，也有相应的“内存管理语义”，由名为<code>objc_AssociationPolicy</code>的枚举所定义。</p>
<p>|             关联类型              | 等效的@property属性 |<br>| :——————————-: | :—————–: |<br>|      OBJC_ASSOCIATION_ASSIGN      |       assign        |<br>|  OBJC_ASSOCIATION_COPY_NONATOMIC  |   nonatomic、copy   |<br>| OBJC_ASSOCIATION_RETAIN_NONATOMIC |  nonatomic、retain  |<br>|       OBJC_ASSOCIATION_COPY       |        copy         |<br>|      OBJC_ASSOCIATION_RETAIN      |       retain        |</p>
</li>
</ul>
</li>
<li><p>管理关联对象的方法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//此方法以给定的键和策略为某对象设置关联对象</span><br><span class="line">- void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line"></span><br><span class="line">//此方法根据给定的键从某对象中获取相应的关联对象值</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);</span><br><span class="line"></span><br><span class="line">//此方法移除指定对象的全部关联对象</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure>
<p>可以把对象想象成NSDictionary，把关联到该对象的值理解为字典的条目，本质的区别在于设置关联对象的key是个不透明的指针，在NSDictionary里如果两个键值相等那么<code>isEqual:</code>方法的返回值就是YES，但是关联对象必须是两个指针相同才行，在设置关联对象的时候通常使用<strong>静态全局变量</strong>做键。</p>
<h4 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h4><ul>
<li>Objective-C的方法调用方式是消息结构，这种传递消息需要有“名称”或“选择子”，可以接受参数，而且可能还有返回值。在Objective-C中，如果向某对象传递消息，那么就会使用动态绑定机制来决定需要调用的方法，当对象收到消息之后，究竟该调用那个方法完全由运行期决定，同时可以在程序运行时改变。</li>
<li>给对象发送消息的例子和过程如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">someObject —— 接受者</span><br><span class="line">messageName —— 选择子</span><br><span class="line">parameter —— 参数</span><br><span class="line">**/</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br><span class="line"></span><br><span class="line">//编译器看到这个消息之后会转换成一条标准的C语言函数调用，调用的是消息中心的核心函数，objc_msgSend</span><br><span class="line">void objc_msgSend(id self, SEL cmd, ...);</span><br><span class="line"></span><br><span class="line">//所以上面那个函数调用经过编译器会转换成如下函数--&gt;</span><br><span class="line">id returnValue = objc_msgSend(someObject,</span><br><span class="line">                              @selector(messageName:),</span><br><span class="line">                              parameter);</span><br><span class="line"></span><br><span class="line">//obj_msgSend函数会依据接受者和选择子的类型来调用适当的方法，为了完成此操作的方法需要在接受者所属类中搜寻方法列表，如果有就跳到其执行的代码，如果没找到就沿着体系继续往上查找，找到合适的方法再跳转。如果还没有，后面就会涉及到消息转发机制。</span><br><span class="line">//obj_msgSend会将匹配结果换存在”快速映射表“里，这样每个类其实都有这样一块缓存，所以执行起来很快，但是还是不如”静态绑定的函数调用操作“那样迅速。</span><br></pre></td></tr></table></figure>
<ul>
<li>除了上述的部分消息的调用过程，还有一些”边界情况“，则需要交由Objective-C运行环境中的一些函数来处理：<ul>
<li>objc_msgSend_stret：如果待发送的消息要返回结构体，那么可以交由此函数处理。需要CPU的寄存器能够容纳这个消息返回的结构体，如果无法容纳就会由另一个函数进行派发，那个函数会通过分配在栈上的某个变量来处理返回的结构体。</li>
<li>objc_msgSend_fpret：如果消息返回的是浮点数，那么需要交由此函数处理。这个函数是为了处理x86等架构CPU中某些奇怪状况。</li>
<li>objc_msgSendSuper：如果要给超类发消息，就给这个函数处理。</li>
</ul>
</li>
<li>如果某函数的最后一项操作是调用另外一个函数，就可以使用“尾调用优化”技术。编译器会生成跳转到另一函数所需要的指令码，而不用向调用堆栈里推入新的”栈帧“。当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用的时候，才能执行”尾调用优化“。</li>
</ul>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><ul>
<li><p>在编译期向类发送了其无法解读的消息并不会报错，因为运行期可以向类中添加方法，所以编译器在编译时无法确定类中到底会不会有某个方法实现。当对象接收到无法解读的消息后，就会启动”消息转发“机制。</p>
</li>
<li><p>消息转发分为两大阶段：</p>
<ul>
<li>第一阶段先征询接受者所属的类，看其是否能动态添加方法，以处理当前这个”未知的选择子“，这部分叫”动态方法解析“。注意这是一个类方法，因为是向接收者所属的类进行请求。</li>
<li>第二阶段涉及”完整的消息转发机制“，这里细分为两小步：<ul>
<li>当对象所属类不能动态添加方法后，<code>runtime</code>就会询问当前的接受者是否有其他对象可以处理这个未知的<code>selector</code>。</li>
<li>当没有备援接收者时，就只剩下最后一次机会，那就是消息重定向。这个时候<code>runtime</code>会将未知消息的所有细节都封装为<code>NSInvocation</code>对象，给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
</li>
<li><p>动态方法解析：</p>
<ul>
<li>对象收到无法解读的消息后，首先调用其所属类的类方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
<p>这种方法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面就可以了。此方案常用来实现<code>@dynamic</code>属性。</p>
<p>Example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//假设这两个方法已经实现</span><br><span class="line">id autoDictionaryGetter(id self,SEL _cmd);</span><br><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value);</span><br><span class="line"></span><br><span class="line">//使用这个类方法进行消息转发</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">    if (/* selector is from a @dynamic property */) &#123;</span><br><span class="line">        if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</span><br><span class="line">            class_addMethod(self,</span><br><span class="line">                            sel,</span><br><span class="line">                            (IMP)autoDictionarySetter,</span><br><span class="line">                            &quot;v@:@&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            class_addMethod(self,</span><br><span class="line">                            sel,</span><br><span class="line">                            (IMP)autoDictionaryGetter,</span><br><span class="line">                            &quot;@@:&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备援接收者：</p>
<ul>
<li>当前接受者还有第二次机会能处理未知的选择子，在这一步中，系统会问该选择子能不能转发给其他接受者。相关的方法为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>虽然Objective-C不支持多重继承，但是通过这个函数的组合我们可以模拟出多次继承的某些特性。</p>
</li>
<li><p>完整的消息转发：</p>
<ul>
<li>首先创建NSInvocation对象，把尚未处理的那条消息的所有细节都封在其中，包括选择子、目标和参数，这个步骤会调用下列方法来转发消息:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation;</span><br></pre></td></tr></table></figure>
<p>实现此方法的时候，如果发现某调用操作不应由本类处理，则需调用超类的同名方法，这样继承体系中的每个类都有机会处理此调用请求，直到NSObject。</p>
</li>
<li><p>消息转发流程：</p>
</li>
</ul>
<p><img src="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/1.png" alt="2"></p>
<h4 id="第13条：用“方法调配技术”调试“黑盒方法”"><a href="#第13条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第13条：用“方法调配技术”调试“黑盒方法”"></a>第13条：用“方法调配技术”调试“黑盒方法”</h4><ul>
<li><p>与给定的选择子名称相对应的方法也可以在运行期改变，不需要知道源代码，也不需要通过继承子类来覆写方法就能够改变这个类本身的功能，新功能会在本类的所有实例中生效，而不仅限于覆写了相关方法的子类实例，这个方案成为“方法调配” (method swizzling)。方法以函数指针的形式来表示，为IMP指针，原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了互换2个已经写好的方法实现，可以使用下列函数：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//此函数的两个参数表示待交换的两个方法实现</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2);</span><br><span class="line"></span><br><span class="line">//方法实现可以通过下列函数获得。</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name);</span><br><span class="line"></span><br><span class="line">//example</span><br><span class="line">//将uppercaseString和lowercaseString两个方法利用方法调配进行调换</span><br><span class="line">Method originalMethod = class_getClassMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">    Method swappedMethod = class_getClassMethod([NSString class], @selector(uppercaseString));</span><br><span class="line">    method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>
<p>除了上面说的两个系统方法的替换，还可以使用自定义的方法和系统方法进行替换，这样的话就能够为那些系统的黑盒方法增加日志记录功能，这个非常有助于程序调试。<strong>很少人会在调试程序之外的场合使用上述方法来永久改变某个类的功能</strong>。</p>
<h4 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h4><ul>
<li>Objective-C有个特殊的类型叫<code>id</code>，他能指代任意类型的Objective-C对象类型。编译器假定它能响应所有消息。<code>id</code>类型本身的定义如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>每个对象结构体的首个成员是<code>Class</code>类的变量，该变量定义了对象所属的类，称为”is a”指针。</p>
<p><code>Class</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>此类结构体存放类的元数据，例如类的实例实现了几个方法，具备多少个实例变量等信息，首个变量也是<code>isa</code>指针，说明<code>Class</code>本身也是Objective-C对象。结构体有个叫做<code>super_class</code>的变量，是本类的超类。类对象所属的类型是另一个类，叫做“元类”，用来表示类对象本身所具备的元数据。每个类仅有一个类对象，每个类对象仅有一个与之相关的元类。</p>
<p>example：</p>
<p>假设有个名为someClass的子类从NSObject继承而来，则既成体系如下所示：</p>
<p><img src="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/2.png" alt="1"></p>
<p><code>super_class</code>指针确立了继承关系，而<code>isa</code>指针描述了实例所属的类。</p>
<ul>
<li><p>在类继承体系中查询类型信息：</p>
<ul>
<li>isMemberOfClass：能够判断出对象是否为某个特定类的实例。</li>
<li>isKindOfClass：能够判断出对象是否为某类或者其派生类的实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary new];</span><br><span class="line">[dict isMemberOfClass:[NSDictionary class]];// NO</span><br><span class="line">[dict isMemberOfClass:[NSMutableDictionary class]];// YES</span><br><span class="line">[dict isKindOfClass:[NSDictionary class]];// YES</span><br><span class="line">[dict isKindOfClass:[NSArray class]];// NO</span><br></pre></td></tr></table></figure>
<p>如果要比较类对象是否等同的话需要使用<code>==</code>操作符，而不是<code>isEqual:</code>，因为类对象是个单例，在应用程序范围内，每个类的<code>Class</code>仅有一个实例。</p>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		10980
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/10/effective-Objective-C2.0总结与笔记-第二章/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/11/09/effective-Objective-C-2-0-总结与笔记（第一章）/">Effective Objective-C 2.0 总结与笔记（第一章）—— 熟悉Objective-C</a>  
	       
		 

		 <time>2018-11-09 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <h3 id="第一章：熟悉Objective-C"><a href="#第一章：熟悉Objective-C" class="headerlink" title="第一章：熟悉Objective-C"></a>第一章：熟悉Objective-C</h3><p>​    本章主要是对Objective-C进行一个了解，通过介绍Objective-C的语法，来讲解Objective-C的基础知识。</p>
<h4 id="第1条：了解Objective-C语言的起源"><a href="#第1条：了解Objective-C语言的起源" class="headerlink" title="第1条：了解Objective-C语言的起源"></a>第1条：了解Objective-C语言的起源</h4><ul>
<li>Objective-C语言采用“消息结构”而非“函数调用”，虽然也是一门面向对象的语言，但是语法比较特别。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息结构:(Objective-C)</span></span><br><span class="line">Object *obj = [Object <span class="keyword">new</span>];</span><br><span class="line">[obj doSomethingWith:someParams];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用:(C++)</span></span><br><span class="line">Object *obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj-&gt;doSomething(someParams);</span><br></pre></td></tr></table></figure>
<p>采用消息结构的语言：执行代码由运行环境决定。</p>
<p>采用函数调用的语言：执行代码由编译器决定。</p>
<ul>
<li>Objective-C的对象所占内存分配在堆空间，不能在栈空间中分配Objective-C对象。通常Objective-C对象类型有一个<code>*</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">someString -&gt; 分配在堆里的某块 含有一个叫&quot;the string&quot;的NSString对象 的内存</span><br><span class="line">anotherString -&gt; someString 指向的那块内存</span><br><span class="line"></span><br><span class="line">只有1个NSString实例，2个变量（指针）在栈帧中被分配了两个内存，内存的值都是上面的堆内存地址</span><br><span class="line">*/</span><br><span class="line">NSString *someString = @&quot;the string&quot;;</span><br><span class="line">NSString *anotherString = someString;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中不含<code>*</code>的可能会使用栈内存，例如<code>CGFloat</code>、<code>CGRect</code> etc.</p>
<h4 id="第2条：在类的头文件中尽量少引入其他头文件"><a href="#第2条：在类的头文件中尽量少引入其他头文件" class="headerlink" title="第2条：在类的头文件中尽量少引入其他头文件"></a>第2条：在类的头文件中尽量少引入其他头文件</h4><ul>
<li>引入有必要的头文件，防止耦合。</li>
<li>当只需要知道这个类名，而不需要使用到里面的一些方法，我们可以使用向前声明的方式代替<code>#import</code>方案。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//向前声明</span><br><span class="line">@class someClass;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在各自的头文件里引入对方的头文件，虽然不会像C++那样导致死循环，但是会导致某个类无法被正确编译。</li>
</ul>
<h4 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h4><ul>
<li>什么是字面量语法？</li>
</ul>
<p>以一种简洁的方式就可以创建对象的方法，而不需要使用<code>alloc</code>和<code>init</code>来分配内存并进行初始化。并且除了字符串以外，所创建的对象必须属于Foundation框架。</p>
<p>example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *someString = @&quot;the String&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>字面量的各种例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//字面量字符串</span><br><span class="line">NSString *someString = @&quot;the String&quot;;</span><br><span class="line"></span><br><span class="line">//字面量数值</span><br><span class="line">NSNumber *intNumber = @1;</span><br><span class="line">NSNumber *floatNumber = @1.5;</span><br><span class="line"></span><br><span class="line">//字面量数组</span><br><span class="line">NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;];</span><br><span class="line">NSString *dog = animals[1];</span><br><span class="line"></span><br><span class="line">//字面量字典</span><br><span class="line">NSDictionary *personData = @[@&quot;firstName&quot; : @&quot;Matt&quot;,</span><br><span class="line">                              @&quot;lastName&quot; : @&quot;Gallway&quot;,</span><br><span class="line">                                   @&quot;age&quot; : @25];</span><br><span class="line">NSString *firstName = personData[@&quot;firstName&quot;];</span><br></pre></td></tr></table></figure>
<ul>
<li>使用字典或者数组的时候，如果值中有nil，则会抛出异常。</li>
</ul>
<h4 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h4><ul>
<li>由于Objective-C里没有命名空间的概念，所以如果使用预处理指令放在头文件里，那么引入该头文件的所有相关属性都会被替换，当常量名称可能冲突的时候，就可能存在一些隐藏的bug。</li>
<li>尽量不要在头文件里声明常量，应该在实现的代码里去声明。同时为了防止占用系统的命名空间，通常每个工程对常量的命名都有自己的命名规范，一般在前面加k。</li>
</ul>
<p>example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//  EOCAnimatedView.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCAnimatedView : UIView</span><br><span class="line"></span><br><span class="line">- (void)animate;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">//  EOCAnimatedView.m</span><br><span class="line"></span><br><span class="line">#import &quot;EOCAnimatedView.h&quot;</span><br><span class="line"></span><br><span class="line">static const NSTimeInterval kAnimationDuration = 0.3;</span><br><span class="line"></span><br><span class="line">@implementation EOCAnimatedView</span><br><span class="line"></span><br><span class="line">- (void)animate &#123;</span><br><span class="line">    [UIView animateWithDuration:kAnimationDuration animations:^&#123;</span><br><span class="line">        //dosomething()</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一定要用const和static来同时修饰该常量，const表示不可被修改，而static则意味着该变量仅在定义此变量的编译单元可见。</p>
<ul>
<li>可以定义一个常量为其他文件所用，此类常量通常放在“全局符号表”中。</li>
</ul>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//header file</span><br><span class="line">extern NSString *const EOCStringConstant;</span><br><span class="line"></span><br><span class="line">//implementation file</span><br><span class="line">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</span><br></pre></td></tr></table></figure>
<p>编译器看到<code>extern</code>关键字，就知道在全局符号表里有一个名为<code>EOCStringConstant</code>的符号，编译器无需查看定义，允许代码使用，因为链接成二进制文件后可以找到这个常量。</p>
<h4 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h4><ul>
<li>一般情况下，编译器会为枚举分配一个独有的编号，从0开始，每次递增1。</li>
<li>建议使用如下方式来声明枚举：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, EOCConectionState) &#123;</span><br><span class="line">    EOCConectionStateDisConnected, //default 0</span><br><span class="line">    EOCConectionStateConnecting, //default 1</span><br><span class="line">    EOCConectionStateConnected //default 2</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>是这样在使用的时候就可以直接使用<code>EOCConectionState</code>作为类型进行声明枚举。其实<code>EOCConectionState</code>本质就是<code>NSUInteger</code>。</p>
<ul>
<li>枚举的命名应当通俗易懂，意义区分明显，不要出现混淆的情况。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2799
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/11/09/effective-Objective-C-2-0-总结与笔记（第一章）/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/06/07/day10-ios学习日记/">day10:iOS学习日记</a>  
	       
		 

		 <time>2018-06-07 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day10: ios学习日记</p>
<p>第21章</p>
<ul>
<li><p>Core Data是一个可以管理模型对象之间关系的框架，可以保存或者读取一部分数据，它会管理这些对象的生命周期，并且更新对象之间的关系。Core Dkata能够在保存/加载对象的时候保持对象的一致性。Core Data会把对象保存在SQLite数据库中。</p>
</li>
<li><p>可变属性：当不存在于Core Data的类型，可以选择可变类型<code>transformable</code>，Core Data可以将对象转换成可存储的内容，然后读取时再转换回来。利用NSValueTransformer来进行转换。</p>
</li>
<li><p>生成NSManagedObject 的子类的时候，xcode8会默认在缓存文件中生成，如果需要自己手动生成的话，需要将codegen改成Manual/None。</p>
</li>
<li><p>navigation的时候，App的初始化一般是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rootViewController = window!.rootViewController <span class="keyword">as</span>! <span class="type">UINavigationController</span></span><br><span class="line"><span class="keyword">let</span> photosViewController = rootViewController.topViewController <span class="keyword">as</span>! <span class="type">PhotoViewController</span>(一开始显示在桌面的controller)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Core Data Stack是由实体相关的类和描述实体如何读/写的模型文件组成，模型文件可以使用NSManagedObjectModel对象表示。</p>
</li>
<li><p>Core Data的几种数据类型</p>
<p>|  SQLite   | 数据使用SQLite数据库保存到硬盘上（通常方法） |<br>| :——-: | :———————–: |<br>|  Atomic   |      数据使用二进制格式存储到硬盘上      |<br>|    XML    |          ios上不支持          |<br>| In-Memory |       保存在内存中而不是硬盘中        |</p>
<p>对象图和数据之间是通过<code>NSPersistentStoreCoordinator</code>对象来管理的。</p>
<p>创建<code>NSPersistentStoreCoordinator</code>对象，需要创建url，然后创建NSPersistentStoreCoordinator对象，创建了coordinator之后，需要指定一个store，运行时，store需要知道存储类型和数据存储的位置。</p>
</li>
<li><p>NSManagedObjectContext是与一个指定的NSPersistantCoordinator相关。NSManagedObjectContext的作用：</p>
<ul>
<li>当需要获取对象的时候，NSManagedObjectContext会通过NSPersistentStoreCoordinator把数据拷贝到内存中。</li>
<li>当需要保存对象的时候，可以调用NSManagedObjectContext的保存方法将数据保存到文件中。当调用保存方法之前，文件系统中的数据还是之前的数据。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> mainQueueContext : <span class="type">NSManagedObjectContext</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span>  moc = <span class="type">NSManagedObjectContext</span>(concurrencyType: .mainQueueConcurrencyType)</span><br><span class="line">    moc.persistentStoreCoordinator = <span class="keyword">self</span>.persistentStoreCoordinator</span><br><span class="line">    moc.name = <span class="string">"Main Queue Context (UI Context)"</span></span><br><span class="line">    <span class="keyword">return</span> moc</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据之后，需要把数据放入NSManagedObjectContext中，保存修改需要去监测NSManagedObjectContext是否有改变，当发生改变了之后，需要调用save函数。</p>
</li>
<li><p>要从NSMangedObjectContext中获取保存的数据，需要创建一个NSFetchRequest对象，获取请求执行之后，会得到符合请求参数的对象数组。利用NSPredicate来创建请求，然后借助sortDescriptors来实现排列顺序，最后通过NSMangedObjectContext来创建请求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchMainQueuePhotots</span><span class="params">(predicate: NSPredicate? = <span class="literal">nil</span>, sortDscriptors : [NSSortDescriptor]? = <span class="literal">nil</span> )</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Photo</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> fetchRequest = <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: <span class="string">"Photo"</span>)</span><br><span class="line">        fetchRequest.sortDescriptors = sortDscriptors</span><br><span class="line">        fetchRequest.predicate = predicate</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> mainQueueContext = <span class="keyword">self</span>.coreDataStack.mainQueueContext</span><br><span class="line">        <span class="keyword">var</span> mainQueuePhotos : [<span class="type">Photo</span>]?</span><br><span class="line">        <span class="keyword">var</span> fetchRequestError : <span class="type">Error</span>?</span><br><span class="line">        mainQueueContext.performAndWait() &#123;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="comment">//mainQueuePhotos = try mainQueueContext.execute(fetchRequest) as? [Photo]</span></span><br><span class="line">                mainQueuePhotos = <span class="keyword">try</span> mainQueueContext.fetch(fetchRequest) <span class="keyword">as</span>? [<span class="type">Photo</span>]</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">                fetchRequestError = error</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> photos = mainQueuePhotos <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> fetchRequestError!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> photos</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在硬盘上保存数据。利用imageStore类（在Homepwner中实现过的），来在照片存储类中添加一个容器，用来保存数据。</p>
</li>
</ul>
<p>第22章</p>
<ul>
<li><p>DataSource类: 实现UITableViewDataSource方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> CoreData</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagDataSource</span> : <span class="title">NSObject</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tags : [<span class="type">NSManagedObject</span>] = []</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tags.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"UITableViewCell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        <span class="keyword">let</span> tag = tags[indexPath.row]</span><br><span class="line">        <span class="keyword">let</span> name = tag.value(forKey: <span class="string">"name"</span>) <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        cell.textLabel?.text = name</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加展示UIAlertController，即弹出对话框:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">addNewTag</span><span class="params">(sender : AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Add a Tag"</span>, message: <span class="literal">nil</span>, preferredStyle: .alert)</span><br><span class="line">    alertController.addTextField(configurationHandler: &#123;</span><br><span class="line">        (textField) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        textField.placeholder = <span class="string">"tag name"</span></span><br><span class="line">       <span class="comment">// textField.autocapitalizationType =</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"ok"</span>, style: .<span class="keyword">default</span>, handler: &#123;</span><br><span class="line">        (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tagName = alertController.textFields?.first?.text &#123;</span><br><span class="line">            <span class="keyword">let</span> context = <span class="keyword">self</span>.store.coreDataStack.mainQueueContext</span><br><span class="line">            <span class="keyword">let</span> newTag = <span class="type">NSEntityDescription</span>.insertNewObject(forEntityName: <span class="string">"Tag"</span>, into: context)</span><br><span class="line">            newTag.setValue(tagName, forKey: <span class="string">"name"</span>)</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="keyword">self</span>.store.coreDataStack.saveChanges()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"core data save failed :<span class="subst">\(error)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.updateTags()</span><br><span class="line">            <span class="keyword">self</span>.tableView.reloadRows(at: [<span class="type">IndexPath</span>.<span class="keyword">init</span>(index: <span class="number">0</span>)], with: .automatic)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    alertController.addAction(okAction) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cancelAction = <span class="type">UIAlertAction</span>(title: <span class="string">"cancel"</span>, style: .cancel, handler: <span class="literal">nil</span>)</span><br><span class="line">    alertController.addAction(cancelAction)</span><br><span class="line">    present(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父子NSManagedObjectContext，不能在主线程中计算大量的工作，否则会阻塞主线程，导致应用无法响应。通常使用多个NSManagedObjectContex。</p>
<p>定义一个后台线程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> privateQueueContext : <span class="type">NSManagedObjectContext</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> moc = <span class="type">NSManagedObjectContext</span>(concurrencyType: .privateQueueConcurrencyType)</span><br><span class="line">    moc.parent = <span class="keyword">self</span>.mainQueueContext</span><br><span class="line">    moc.name = <span class="string">"primary private queue context"</span></span><br><span class="line">    <span class="keyword">return</span> moc</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		4478
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/06/07/day10-ios学习日记/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/06/07/day9-ios学习日记/">day9:iOS学习日记</a>  
	       
		 

		 <time>2018-06-07 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day9:ios学习日记</p>
<p>第19章</p>
<p>这一章好难啊，感觉看了快一天，而且熟练度不够，需要再重新仔细看代码才行。</p>
<ul>
<li><p>利用URL的键值对来访问请求信息。可以利用枚举来建立响应的方法，方便后面进行使用。</p>
</li>
<li><p>在swift中，关于访问控制有三种:</p>
<p>| public         | internal                   | private                |<br>| ————– | ————————– | ———————- |<br>| 所有文件，包括第三方库的文件 | 默认值，对于app来说，只有当前项目的文件可以访问。 | 只有当前文件可以访问这个类，而不是当前的类。 |</p>
</li>
<li><p>闭包是很神奇的东西，不过由于见的比较少，在重新查看并通过一个例子之后终于理解了逃逸闭包的使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">逃逸闭包:当函数执行结束后,才去调用函数内部的闭包,叫做逃逸闭包</span><br><span class="line">非逃逸闭包:当函数执行过程中,执行的函数内部的闭包,叫做非逃逸闭包,默认情况下，是非逃逸闭包。</span><br><span class="line">-如果函数的最后一个参数是闭包,函数参数可以提前结束,最后一个参数直接使用&#123;&#125;,包装闭包的代码。</span><br></pre></td></tr></table></figure>
<p>例如这一段代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  Test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by gdgd on 18/5/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018年 gdgd. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        loadData &#123; (json: [<span class="type">String</span>]) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(json)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setupUI &#123; (result) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadData</span><span class="params">(completion:@escaping <span class="params">(<span class="number">_</span> : [String])</span></span></span>-&gt;()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"当前的线程<span class="subst">\(Thread.current)</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> json = [<span class="string">"lausen"</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"当前的线程<span class="subst">\(Thread.current)</span>"</span>);</span><br><span class="line">                </span><br><span class="line">                completion(json)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"执行到这儿结束了"</span>) <span class="comment">//函数结束后才去调用的闭包这个就是逃逸闭包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span><span class="params">(completion: <span class="params">(<span class="number">_</span> : [String])</span></span></span> -&gt; ()) &#123; <span class="comment">//而这个就是非逃逸闭包</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> json = [<span class="string">"liuxiang"</span>,<span class="string">"lausen"</span>,<span class="string">"somnus"</span>]</span><br><span class="line">        </span><br><span class="line">        completion(json)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前一直对于闭包作为参数有了一定的误会，以为在定义逃逸闭包的时候，就已经决定了他要做什么事情，但其实是在调用<strong>具有该闭包的参数的函数</strong>的时候，才会具体去实现闭包的具体内容。例如在这个例子中，虽然在逃逸闭包的定义里有一些输出，例如输出当前线程什么的，但是逃逸闭包的具体实现是在<code>viewDidLoad</code>里调用<code>loadData</code>的时候，对获得到到json数据，进行输出。最后输出结果为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"liuxiang"</span>, <span class="string">"lausen"</span>, <span class="string">"somnus"</span>]</span><br><span class="line">当前的线程&lt;<span class="type">NSThread</span>: <span class="number">0x608000071980</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;)</span><br><span class="line">执行到这儿结束了</span><br><span class="line">当前的线程&lt;<span class="type">NSThread</span>: <span class="number">0x600000065a00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">[<span class="string">"lausen"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>URLSession提供了和服务器进行通信的方法，其中URLSessionTask负责与服务器进行通信。URLSessionTask分为三种任务：数据任务、下载任务、上传任务。</p>
</li>
<li>捋一捋程序的思路：发送请求到服务器 -&gt; 获取JSON数据 -&gt; 构建解析JSON数据的模型 -&gt; 利用JSONSerialization来把数据转换成为基础对象即已定义的解析JSON数据的模型 -&gt; 将成功转换的数据转换成为Image对象显示出来。</li>
<li>默认情况下，由于访问网络时间可能很久，所以URLSessionTask在后台线程中运行，而更新UI需要在主线程，即<code>OperationQueue.main.addOperation</code></li>
</ul>
<p>第20章</p>
<ul>
<li><p>定义数据源，遵循UICollectionViewDataSouce协议的同时，也需要遵循NSObjectProtocol，可以采用直接继承NSObject类来实现。一定要实现的方法为:<code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell</code>和  <code>func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int</code> </p>
<p>一个是查询需要显示多少数据，另一个是用来获取指定位置的UICollectionViewCell。</p>
</li>
<li><p>使用扩展可以对自定义的类或者系统框架的类中添加方法，类、结构体和枚举都支持扩展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">calss <span class="type">A</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">A</span>: <span class="title">Equatable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> == <span class="params">(leftvar:A, rightvar: B)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftvar.a  == rightvar.a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2501
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/06/07/day9-ios学习日记/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/06/06/day8-ios学习日记/">day8:iOS学习日记</a>  
	       
		 

		 <time>2018-06-06 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>day8:ios学习笔记</p>
<p>第17章</p>
<ul>
<li><p>UIView是UIResponder的子类，我们可以直接通过覆盖以下4个函数来处理触摸事件，即可完成画图的工作，当应用某个触摸事件发生后，系统都会将该事件添加至一个由UIApplication单例管理的事件队列中，然后UIApplication会向拥有该事件的视图发送特定的UIResponder消息。当多个手指在同一视图、同一时刻执行相同的触摸操作的时候，会采用单个消息、一次分发所有相关的UITouch对象的方式。注意：在这个例子中，不需要也不应该去保存UITouch对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesCancelled</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体和类的区别：</p>
<ul>
<li>结构体不支持继承</li>
<li>如果没有定义构造方法，结构体默认由一个根据成员生成的构造函数。</li>
<li>如果所有属性都有默认值，并且没有定义其他构造方法，结构体会有默人的一个空构造方法来创建结构体并设置默认值。</li>
<li>结构体是值类型的，而类是指针类型的。</li>
</ul>
</li>
<li><p>重载drawRect的时候，进行画图操作，当添加新线之后，调用setNeedDisplay()函数来进行调用drawRect。</p>
</li>
<li><p>利用IBInspectable来让代码中的属性和Interface Builder的属性相关联。</p>
</li>
<li><p>UIResponder对象可以成为第一响应对象并接受触摸事件，例如UIView,UIViewController,UIApplication,UIWindow。UIResponder对象有一个nextResponder()对象，这些对象一起组成了响应链。当UIResponder不处理某个事件时，就会把这个事件传递给nextResponder()方法，如果最终的UIApplication也没有处理这个事件，那么这个事件就会被忽略。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应链顺序：</span><br><span class="line"><span class="type">UIView</span> -&gt; father <span class="type">UIView</span> -&gt; <span class="type">UIViewController</span> -&gt; <span class="type">UIWindow</span> -&gt; <span class="type">UIApplication</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>UIControl是Cocoa Touch中很多类的父类，它不会直接向目标对象发送消息，而是通过UIApplication对象来进行转发。例如UIButton对象，要处理其事件的时候，是先通过UIControl的方法先对其是那种类型事件进行判断，然后再调用自身的sendActionsForControlEvents(_:)方法去查询目标动作对来进行匹配。如果UICtrol对象直接向目标对象发送消息，由于UIControl的目标－动作对中，可能目标对象为nil的情况，而通过UIApplication来转发会先进行判断对象是否为nil，如果是nil，那么UIApplication就会找出UIWindow对象的第一响应对象发送响应的动作消息。UIApplication对象是应用程序的象征，一个UIApplication就是一个应用程序，是以单例模式存在。</p>
</li>
</ul>
<p>第18章</p>
<ul>
<li><p>UIGestureRecognizer有很多子类，例如UITapGestureRecognizer,UILongPressGestureRecognizer 等，利用这些子类能够处理不同的手势。</p>
</li>
<li><p>delaysTouchesBegan，设置属性为true的时候，能够使得该手势延迟调用TouchBegan函数。</p>
</li>
<li><p>gesture1.require(toFail: gesture2 )能够使得gesture1在gesture2识别失败后再进行识别。</p>
</li>
<li><p>location(in:view)可以获取手势的位置。</p>
</li>
<li><p>一个应用只有一个UIMenuController，当需要展示他的时候，给他设置UIMenuItem,设置显示区域，设置可见即可。为了让其显示，需要将当前的View设置成第一响应对象，即重载<strong>变量</strong>canBecomeFirstResponder ,变量也可以进行重载！然后在显示menu之前，调用becomeFirstResponder()，再添加Item，设置显示区域，设置可见即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> canBecomeFirstResponder: <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将UIGestureRecognizer的cancelsTouchesInView属性设置成false，即可确保手势处理触摸事件后视图仍然可以通过UIResponder方法收到触摸事件。</p>
</li>
<li><p>当一个手势识别成功需要去识别另一个手势的时候，可以重载委托的这个函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gestureRecognizer</span><span class="params">(<span class="number">_</span> gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手势一共有7种状态:</p>
<p>|     状态      |                    意义                    |<br>| :———: | :————————————–: |<br>|  .possible  |   手势识别器还没有识别它的手势，但是可能正在评估触摸事件。这是默认状态。    |<br>|   .failed   | 手势识别器已经接收到不能识别为其手势的多点触摸序列。没有发送动作消息，手势识别器被重置为.possible |<br>|   .began    | 手势识别器已经接收到被识别为连续手势的触摸物体。它在运行循环的下一个周期发送其动作消息（或消息）。 |<br>|  .changed   | 手势识别器已经接收到被识别为对连续手势的改变的触摸。它在运行循环的下一个周期发送其动作消息（或消息）。 |<br>|   .ended    | 手势识别器已经接收到被识别为连续手势结束的触摸。它在运行循环的下一个周期发送其动作消息（或消息），并将其状态重置为.possible |<br>| .cancelled  | 手势识别器已经接收到触摸，从而导致连续手势的取消。它在运行循环的下一个周期发送其动作消息（或消息），并将其状态重置为.possible |<br>| .recognized | 手势识别器已经接收到它识别为手势的多点触摸序列。它在运行循环的下一个周期发送其动作消息（或消息），并将其状态重置为.possible |</p>
</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2784
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/06/06/day8-ios学习日记/">阅读更多</a> 
    	
</article>     
     	
      	  	

  		
    	<article class="article">		
	   
	<div class="article-header">
	    
	     <a class="article-title"  href="/2018/05/25/day7-ios学习笔记/">day7:iOS学习笔记</a>  
	       
		 

		 <time>2018-05-25 </time>    
	</div>


    <div class="post-content article-excerpt">	
	
  	

	   <p>第15章</p>
<ul>
<li><p>固化是由ios sdk提供的一种保存和读取对象的机制，固化某个对象的时候，会将该对象的所有属性存入指定的文件中，解固某个对象的时候，会从制定的文件中读取相应的数据，然后根据数据还原对象。</p>
</li>
<li><p>为了实现固化和解固，相应对象的类需要遵循NSCoding协议，其中有两个必须要实现的方法：encodeWithCoder(_: )和init(coder: )。</p>
</li>
<li><p>NSCoder会将要固化的类转换成键值对的形式写入指定的文件中。</p>
</li>
<li><p>每个应用都有自己的应用沙盒，应用的数据都存储在应用沙盒中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Documents</span>/ 		存储应用产生的需要保存的数据，可以进行备份。</span><br><span class="line"><span class="type">Library</span>/<span class="type">Caches</span>/ 	存储临时数据，保存在本机中，即应用缓存，不会备份。</span><br><span class="line"><span class="type">Library</span>/<span class="type">Perferences</span> 	存放应用设置和<span class="type">NSUserdefaults</span>的数据，会同步。</span><br><span class="line">tmp/ 	存放临时数据，应用没有运行的时候可以进行清除。</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件URL的demo如下：urls(for:in:)这个函数是用来在用户文件夹中查找相应的文件夹，在IOS中，in里的参数都是使用.userDomainMask，然后选择找到的第一个文件夹，然后在其中创建一个叫做”items.archive”的文件，注意是appending不是append，查阅api文档可以得知appendingPathComponent是有返回参数的，而appendPathComponent只是单纯的动作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z    <span class="keyword">let</span> itemArchiveURL : <span class="type">URL</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> documentsDirectories = <span class="type">FileManager</span>.<span class="keyword">default</span>.urls(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask)</span><br><span class="line">        <span class="keyword">let</span> documentDirectory = documentsDirectories.first!</span><br><span class="line">        <span class="keyword">return</span> documentDirectory.appendingPathComponent(<span class="string">"items.archive"</span>)</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了保存应用的信息，可以调用NSKeyedArchiver.archiveRootObject(obj, to File:)，这段代码能够将要保存的对象存放到目标文件中，具体到原理是利用同一个NSKeyedArchiver对象作为参数，来让所有的对象(已经实现了NSCoding协议)发送encodeWithCoder消息，而每一个对象也会向其子对象发送该参数并发送encodeWithCoder消息。当所有对象完成编码后，NSKeyedArchiver对象会将数据写入文件中。这也是固化的过程了。</p>
</li>
<li><p>每个类（包括自己建立）都有一个初始化方法，一般情况下，为了加载已经存储的数据，可以利用解固的方式: 借助NSKeyedUnarchiver来实现，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> archivedItems = <span class="type">NSKeyedUnarchiver</span>.unarchiveObject(withFile: itemArchiveURL.path) <span class="keyword">as</span>? [<span class="type">Item</span>] &#123;</span><br><span class="line">            allItems += archivedItems</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用切换的时候，app的状态切换如下所示，即调用AppDelegate中的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打开应用，会调用: application(<span class="number">_</span>:didFinishLaunchingWithOptions:)和applicationDidBecomeActive</span><br><span class="line">按下home键，会调用: applicationWillResignActive和applicationDidEnterBackground</span><br><span class="line">重新回到应用，会调用:applicationWillEnterForeground和applicationDidBecomeActive</span><br><span class="line">双击home键到切换应用界面类似按下home键的操作。</span><br><span class="line">按下锁屏，会调用:applicationWillResignActive和applicationDidEnterBackground</span><br><span class="line">在切换应用界面将应用终止，系统会终止应用，但应用的委托对象不会收到任何信息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>guard能够让代码更简洁，让方法在不满足条件的时候提前跳出，只有当表达式为true的时候，才会执行表达式，具体语法为: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> expression <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误处理代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> throwing expression</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第16章</p>
<p>为了在不同的界面显示不同的内容，即适配横屏和竖屏，我们需要专门定制某个界面。</p>
<ul>
<li>SizeClass有四种组合，可以在main.storyboard中直接进行预览。</li>
<li>定制特定的视图的时候，可以在对应部件中设置显示条件。</li>
<li>如果是要改上下布局为左右布局，可以将整体放在UIStackView中，更方便进行操作。</li>
</ul>
    
	  
</div>




	<div class="article-info">
		

	<span class="post-meta">		
	<span class="iconfont icon-category"></span>
		<a class="category-link" href="/categories/iOS/">iOS</a>
	</span>		
	


				
	<span class="post-meta">
	<span class="iconfont icon-tag"></span>
		<a class="tag-link" href="/tags/iOS/">iOS</a> <a class="tag-link" href="/tags/笔记/">笔记</a>
	</span>			
	



	<span class="post-words"><span class="iconfont icon-words"></span>
		2091
	</span>
		
	</div>
		

		
    <a class="article-readmore" href="/2018/05/25/day7-ios学习笔记/">阅读更多</a> 
    	
</article>     
     	
  

 

  <nav class="paginator scrollIn">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  


        </section> 

    </div>        

    
    
    <div id="backTop" class="iconfont icon-backtotop sildeUpMin"></div> 

    

        
        <div class="search-container sildeUpMin">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
              <span class="search-cancel iconfont icon-cancel"></span>
              <div id="search-result" class="search-result"></div>
        </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src= "/images/favicon.png" >   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/categories">分类
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>     


    <footer id="footer">
	   
   	 

	  	
   	
	   
      	 

	
	

	 <div>
	 	&copy;
				
		2017-
		
		2018			
	
		
		PengGuodong	 

	 </div>
	
   
   	 <div>
	
	 <a href="http://hexo.io/" target="_blank">Hexo</a>

	 Theme

	 <a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a> 

	 </div>	


	
	
</footer>    
    

<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>





 
    
    
    <script src="/main.bundle.js"></script>        
  </body>        
</html>